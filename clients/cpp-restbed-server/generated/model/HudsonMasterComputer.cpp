/**
 * Swaggy Jenkins
 * Jenkins API clients generated from Swagger / Open API specification
 *
 * OpenAPI spec version: 1.1.1
 * Contact: blah@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 3.2.1-SNAPSHOT.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "HudsonMasterComputer.h"

#include <string>
#include <sstream>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>

using boost::property_tree::ptree;
using boost::property_tree::read_json;
using boost::property_tree::write_json;

namespace org {
namespace openapitools {
namespace server {
namespace model {

HudsonMasterComputer::HudsonMasterComputer()
{
    m__class = "";
    m_DisplayName = "";
    m_Icon = "";
    m_IconClassName = "";
    m_Idle = false;
    m_JnlpAgent = false;
    m_LaunchSupported = false;
    m_ManualLaunchAllowed = false;
    m_NumExecutors = 0;
    m_Offline = false;
    m_OfflineCause = "";
    m_OfflineCauseReason = "";
    m_TemporarilyOffline = false;
    
}

HudsonMasterComputer::~HudsonMasterComputer()
{
}

std::string HudsonMasterComputer::toJsonString()
{
	std::stringstream ss;
	ptree pt;
	pt.put("_class", m__class);
	pt.put("DisplayName", m_DisplayName);
	pt.put("Icon", m_Icon);
	pt.put("IconClassName", m_IconClassName);
	pt.put("Idle", m_Idle);
	pt.put("JnlpAgent", m_JnlpAgent);
	pt.put("LaunchSupported", m_LaunchSupported);
	pt.put("ManualLaunchAllowed", m_ManualLaunchAllowed);
	pt.put("NumExecutors", m_NumExecutors);
	pt.put("Offline", m_Offline);
	pt.put("OfflineCause", m_OfflineCause);
	pt.put("OfflineCauseReason", m_OfflineCauseReason);
	pt.put("TemporarilyOffline", m_TemporarilyOffline);
	write_json(ss, pt, false);
	return ss.str();
}

void HudsonMasterComputer::fromJsonString(std::string const& jsonString)
{
	std::stringstream ss(jsonString);
	ptree pt;
	read_json(ss,pt);
	m__class = pt.get("_class", "");
	m_DisplayName = pt.get("DisplayName", "");
	m_Icon = pt.get("Icon", "");
	m_IconClassName = pt.get("IconClassName", "");
	m_Idle = pt.get("Idle", false);
	m_JnlpAgent = pt.get("JnlpAgent", false);
	m_LaunchSupported = pt.get("LaunchSupported", false);
	m_ManualLaunchAllowed = pt.get("ManualLaunchAllowed", false);
	m_NumExecutors = pt.get("NumExecutors", 0);
	m_Offline = pt.get("Offline", false);
	m_OfflineCause = pt.get("OfflineCause", "");
	m_OfflineCauseReason = pt.get("OfflineCauseReason", "");
	m_TemporarilyOffline = pt.get("TemporarilyOffline", false);
}

std::string HudsonMasterComputer::getClass() const
{
    return m__class;
}
void HudsonMasterComputer::setClass(std::string value)
{
    m__class = value;
}
std::string HudsonMasterComputer::getDisplayName() const
{
    return m_DisplayName;
}
void HudsonMasterComputer::setDisplayName(std::string value)
{
    m_DisplayName = value;
}
std::vector<std::shared_ptr<HudsonMasterComputerexecutors>> HudsonMasterComputer::getExecutors() const
{
    return m_Executors;
}
void HudsonMasterComputer::setExecutors(std::vector<std::shared_ptr<HudsonMasterComputerexecutors>> value)
{
    m_Executors = value;
}
std::string HudsonMasterComputer::getIcon() const
{
    return m_Icon;
}
void HudsonMasterComputer::setIcon(std::string value)
{
    m_Icon = value;
}
std::string HudsonMasterComputer::getIconClassName() const
{
    return m_IconClassName;
}
void HudsonMasterComputer::setIconClassName(std::string value)
{
    m_IconClassName = value;
}
bool HudsonMasterComputer::isIdle() const
{
    return m_Idle;
}
void HudsonMasterComputer::setIdle(bool value)
{
    m_Idle = value;
}
bool HudsonMasterComputer::isJnlpAgent() const
{
    return m_JnlpAgent;
}
void HudsonMasterComputer::setJnlpAgent(bool value)
{
    m_JnlpAgent = value;
}
bool HudsonMasterComputer::isLaunchSupported() const
{
    return m_LaunchSupported;
}
void HudsonMasterComputer::setLaunchSupported(bool value)
{
    m_LaunchSupported = value;
}
std::shared_ptr<Label1> HudsonMasterComputer::getLoadStatistics() const
{
    return m_LoadStatistics;
}
void HudsonMasterComputer::setLoadStatistics(std::shared_ptr<Label1> value)
{
    m_LoadStatistics = value;
}
bool HudsonMasterComputer::isManualLaunchAllowed() const
{
    return m_ManualLaunchAllowed;
}
void HudsonMasterComputer::setManualLaunchAllowed(bool value)
{
    m_ManualLaunchAllowed = value;
}
std::shared_ptr<HudsonMasterComputermonitorData> HudsonMasterComputer::getMonitorData() const
{
    return m_MonitorData;
}
void HudsonMasterComputer::setMonitorData(std::shared_ptr<HudsonMasterComputermonitorData> value)
{
    m_MonitorData = value;
}
int32_t HudsonMasterComputer::getNumExecutors() const
{
    return m_NumExecutors;
}
void HudsonMasterComputer::setNumExecutors(int32_t value)
{
    m_NumExecutors = value;
}
bool HudsonMasterComputer::isOffline() const
{
    return m_Offline;
}
void HudsonMasterComputer::setOffline(bool value)
{
    m_Offline = value;
}
std::string HudsonMasterComputer::getOfflineCause() const
{
    return m_OfflineCause;
}
void HudsonMasterComputer::setOfflineCause(std::string value)
{
    m_OfflineCause = value;
}
std::string HudsonMasterComputer::getOfflineCauseReason() const
{
    return m_OfflineCauseReason;
}
void HudsonMasterComputer::setOfflineCauseReason(std::string value)
{
    m_OfflineCauseReason = value;
}
bool HudsonMasterComputer::isTemporarilyOffline() const
{
    return m_TemporarilyOffline;
}
void HudsonMasterComputer::setTemporarilyOffline(bool value)
{
    m_TemporarilyOffline = value;
}

}
}
}
}

