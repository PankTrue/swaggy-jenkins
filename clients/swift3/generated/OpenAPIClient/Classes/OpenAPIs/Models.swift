// Models.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

protocol JSONEncodable {
    func encodeToJSON() -> Any
}

public enum ErrorResponse : Error {
    case HttpError(statusCode: Int, data: Data?, error: Error)
    case DecodeError(response: Data?, decodeError: DecodeError)
}

open class Response<T> {
    open let statusCode: Int
    open let header: [String: String]
    open let body: T?

    public init(statusCode: Int, header: [String: String], body: T?) {
        self.statusCode = statusCode
        self.header = header
        self.body = body
    }

    public convenience init(response: HTTPURLResponse, body: T?) {
        let rawHeader = response.allHeaderFields
        var header = [String:String]()
        for case let (key, value) as (String, String) in rawHeader {
            header[key] = value
        }
        self.init(statusCode: response.statusCode, header: header, body: body)
    }
}

public enum Decoded<ValueType> {
    case success(ValueType)
    case failure(DecodeError)
}

public extension Decoded {
    var value: ValueType? {
        switch self {
        case let .success(value):
            return value
        case .failure:
            return nil
        }
    }
}

public enum DecodeError {
    case typeMismatch(expected: String, actual: String)
    case missingKey(key: String)
    case parseError(message: String)
}

private var once = Int()
class Decoders {
    static fileprivate var decoders = Dictionary<String, ((AnyObject, AnyObject?) -> AnyObject)>()

    static func addDecoder<T>(clazz: T.Type, decoder: @escaping ((AnyObject, AnyObject?) -> Decoded<T>)) {
        let key = "\(T.self)"
        decoders[key] = { decoder($0, $1) as AnyObject }
    }

    static func decode<T>(clazz: T.Type, discriminator: String, source: AnyObject) -> Decoded<T> {
        let key = discriminator
        if let decoder = decoders[key], let value = decoder(source, nil) as? Decoded<T> {
            return value
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decode<T>(clazz: [T].Type, source: AnyObject) -> Decoded<[T]> {
        if let sourceArray = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in sourceArray {
                switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                case let .success(value):
                    values.append(value)
                case let .failure(error):
                    return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decode<T>(clazz: T.Type, source: AnyObject) -> Decoded<T> {
        switch Decoders.decode(clazz: T.self, source: source, instance: nil) {
    	    case let .success(value):
                return .success(value)
            case let .failure(error):
                return .failure(error)
        }
    }

    static open func decode<T: RawRepresentable>(clazz: T.Type, source: AnyObject) -> Decoded<T> {
        if let value = source as? T.RawValue {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "\(T.RawValue.self) matching a case from the enumeration \(T.self)", actual: String(describing: type(of: source))))
        }
    }

    static func decode<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject) -> Decoded<[Key:T]> {
        if let sourceDictionary = source as? [Key: AnyObject] {
            var dictionary = [Key:T]()
            for (key, value) in sourceDictionary {
                switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                case let .success(value):
                    dictionary[key] = value
                case let .failure(error):
                    return .failure(error)
                }
            }
            return .success(dictionary)
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decodeOptional<T: RawRepresentable>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
        guard !(source is NSNull), source != nil else { return .success(nil) }
        if let value = source as? T.RawValue {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "\(T.RawValue.self) matching a case from the enumeration \(T.self)", actual: String(describing: type(of: source))))
        }
    }

    static func decode<T>(clazz: T.Type, source: AnyObject, instance: AnyObject?) -> Decoded<T> {
        initialize()
        if let sourceNumber = source as? NSNumber, let value = sourceNumber.int32Value as? T, T.self is Int32.Type {
            return .success(value)
        }
        if let sourceNumber = source as? NSNumber, let value = sourceNumber.int32Value as? T, T.self is Int64.Type {
     	    return .success(value)
        }
        if let intermediate = source as? String, let value = UUID(uuidString: intermediate) as? T, source is String, T.self is UUID.Type {
            return .success(value)
        }
        if let value = source as? T {
            return .success(value)
        }
        if let intermediate = source as? String, let value = Data(base64Encoded: intermediate) as? T {
            return .success(value)
        }

        let key = "\(T.self)"
        if let decoder = decoders[key], let value = decoder(source, instance) as? Decoded<T> {
           return value
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    //Convert a Decoded so that its value is optional. DO WE STILL NEED THIS?
    static func toOptional<T>(decoded: Decoded<T>) -> Decoded<T?> {
        return .success(decoded.value)
    }

    static func decodeOptional<T>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
        if let source = source, !(source is NSNull) {
            switch Decoders.decode(clazz: clazz, source: source, instance: nil) {
            case let .success(value): return .success(value)
            case let .failure(error): return .failure(error)
            }
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> Decoded<[T]?> where T: RawRepresentable {
        if let source = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in source {
                switch Decoders.decodeOptional(clazz: T.self, source: sourceValue) {
                case let .success(value): if let value = value { values.append(value) }
                case let .failure(error): return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> Decoded<[T]?> {
        if let source = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in source {
                switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                case let .success(value): values.append(value)
                case let .failure(error): return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject?) -> Decoded<[Key:T]?> {
        if let sourceDictionary = source as? [Key: AnyObject] {
            var dictionary = [Key:T]()
            for (key, value) in sourceDictionary {
                switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                case let .success(value): dictionary[key] = value
                case let .failure(error): return .failure(error)
                }
            }
            return .success(dictionary)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T: RawRepresentable, U: AnyObject>(clazz: T, source: AnyObject) -> Decoded<T?> where T.RawValue == U {
        if let value = source as? U {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "String", actual: String(describing: type(of: source))))
        }
    }


    private static var __once: () = {
        let formatters = [
            "yyyy-MM-dd",
            "yyyy-MM-dd'T'HH:mm:ssZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss'Z'",
            "yyyy-MM-dd'T'HH:mm:ss.SSS",
            "yyyy-MM-dd HH:mm:ss"
        ].map { (format: String) -> DateFormatter in
            let formatter = DateFormatter()
            formatter.locale = Locale(identifier: "en_US_POSIX")
            formatter.dateFormat = format
            return formatter
        }
        // Decoder for Date
        Decoders.addDecoder(clazz: Date.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Date> in
           if let sourceString = source as? String {
                for formatter in formatters {
                    if let date = formatter.date(from: sourceString) {
                        return .success(date)
                    }
                }
            }
            if let sourceInt = source as? Int {
                // treat as a java date
                return .success(Date(timeIntervalSince1970: Double(sourceInt / 1000) ))
            }
            if source is String || source is Int {
                return .failure(.parseError(message: "Could not decode date"))
            } else {
                return .failure(.typeMismatch(expected: "String or Int", actual: "\(source)"))
            }
        }

        // Decoder for ISOFullDate
        Decoders.addDecoder(clazz: ISOFullDate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ISOFullDate> in
            if let string = source as? String,
               let isoDate = ISOFullDate.from(string: string) {
                return .success(isoDate)
            } else {
            	return .failure(.typeMismatch(expected: "ISO date", actual: "\(source)"))
            }
        }

        // Decoder for [AllView]
        Decoders.addDecoder(clazz: [AllView].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AllView]> in
            return Decoders.decode(clazz: [AllView].self, source: source)
        }

        // Decoder for AllView
        Decoders.addDecoder(clazz: AllView.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AllView> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AllView() : instance as! AllView
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["url"] as AnyObject?) {
                
                case let .success(value): _result.url = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AllView", actual: "\(source)"))
            }
        }
        // Decoder for [Body]
        Decoders.addDecoder(clazz: [Body].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Body]> in
            return Decoders.decode(clazz: [Body].self, source: source)
        }

        // Decoder for Body
        Decoders.addDecoder(clazz: Body.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Body> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Body() : instance as! Body
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["favorite"] as AnyObject?) {
                
                case let .success(value): _result.favorite = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Body", actual: "\(source)"))
            }
        }
        // Decoder for [BranchImpl]
        Decoders.addDecoder(clazz: [BranchImpl].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[BranchImpl]> in
            return Decoders.decode(clazz: [BranchImpl].self, source: source)
        }

        // Decoder for BranchImpl
        Decoders.addDecoder(clazz: BranchImpl.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BranchImpl> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? BranchImpl() : instance as! BranchImpl
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["displayName"] as AnyObject?) {
                
                case let .success(value): _result.displayName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["estimatedDurationInMillis"] as AnyObject?) {
                
                case let .success(value): _result.estimatedDurationInMillis = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fullDisplayName"] as AnyObject?) {
                
                case let .success(value): _result.fullDisplayName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fullName"] as AnyObject?) {
                
                case let .success(value): _result.fullName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["organization"] as AnyObject?) {
                
                case let .success(value): _result.organization = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [StringParameterDefinition].self, source: sourceDictionary["parameters"] as AnyObject?) {
                
                case let .success(value): _result.parameters = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: BranchImplpermissions.self, source: sourceDictionary["permissions"] as AnyObject?) {
                
                case let .success(value): _result.permissions = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["weatherScore"] as AnyObject?) {
                
                case let .success(value): _result.weatherScore = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["pullRequest"] as AnyObject?) {
                
                case let .success(value): _result.pullRequest = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: BranchImpllinks.self, source: sourceDictionary["_links"] as AnyObject?) {
                
                case let .success(value): _result.links = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: PipelineRunImpl.self, source: sourceDictionary["latestRun"] as AnyObject?) {
                
                case let .success(value): _result.latestRun = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "BranchImpl", actual: "\(source)"))
            }
        }
        // Decoder for [BranchImpllinks]
        Decoders.addDecoder(clazz: [BranchImpllinks].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[BranchImpllinks]> in
            return Decoders.decode(clazz: [BranchImpllinks].self, source: source)
        }

        // Decoder for BranchImpllinks
        Decoders.addDecoder(clazz: BranchImpllinks.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BranchImpllinks> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? BranchImpllinks() : instance as! BranchImpllinks
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["self"] as AnyObject?) {
                
                case let .success(value): _result._self = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["actions"] as AnyObject?) {
                
                case let .success(value): _result.actions = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["runs"] as AnyObject?) {
                
                case let .success(value): _result.runs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["queue"] as AnyObject?) {
                
                case let .success(value): _result.queue = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "BranchImpllinks", actual: "\(source)"))
            }
        }
        // Decoder for [BranchImplpermissions]
        Decoders.addDecoder(clazz: [BranchImplpermissions].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[BranchImplpermissions]> in
            return Decoders.decode(clazz: [BranchImplpermissions].self, source: source)
        }

        // Decoder for BranchImplpermissions
        Decoders.addDecoder(clazz: BranchImplpermissions.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BranchImplpermissions> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? BranchImplpermissions() : instance as! BranchImplpermissions
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["create"] as AnyObject?) {
                
                case let .success(value): _result.create = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["read"] as AnyObject?) {
                
                case let .success(value): _result.read = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["start"] as AnyObject?) {
                
                case let .success(value): _result.start = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["stop"] as AnyObject?) {
                
                case let .success(value): _result.stop = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "BranchImplpermissions", actual: "\(source)"))
            }
        }
        // Decoder for [CauseAction]
        Decoders.addDecoder(clazz: [CauseAction].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CauseAction]> in
            return Decoders.decode(clazz: [CauseAction].self, source: source)
        }

        // Decoder for CauseAction
        Decoders.addDecoder(clazz: CauseAction.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CauseAction> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CauseAction() : instance as! CauseAction
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [CauseUserIdCause].self, source: sourceDictionary["causes"] as AnyObject?) {
                
                case let .success(value): _result.causes = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CauseAction", actual: "\(source)"))
            }
        }
        // Decoder for [CauseUserIdCause]
        Decoders.addDecoder(clazz: [CauseUserIdCause].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CauseUserIdCause]> in
            return Decoders.decode(clazz: [CauseUserIdCause].self, source: source)
        }

        // Decoder for CauseUserIdCause
        Decoders.addDecoder(clazz: CauseUserIdCause.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CauseUserIdCause> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CauseUserIdCause() : instance as! CauseUserIdCause
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["shortDescription"] as AnyObject?) {
                
                case let .success(value): _result.shortDescription = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["userId"] as AnyObject?) {
                
                case let .success(value): _result.userId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["userName"] as AnyObject?) {
                
                case let .success(value): _result.userName = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CauseUserIdCause", actual: "\(source)"))
            }
        }
        // Decoder for [ClassesByClass]
        Decoders.addDecoder(clazz: [ClassesByClass].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ClassesByClass]> in
            return Decoders.decode(clazz: [ClassesByClass].self, source: source)
        }

        // Decoder for ClassesByClass
        Decoders.addDecoder(clazz: ClassesByClass.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ClassesByClass> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ClassesByClass() : instance as! ClassesByClass
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["classes"] as AnyObject?) {
                
                case let .success(value): _result.classes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ClassesByClass", actual: "\(source)"))
            }
        }
        // Decoder for [ClockDifference]
        Decoders.addDecoder(clazz: [ClockDifference].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ClockDifference]> in
            return Decoders.decode(clazz: [ClockDifference].self, source: source)
        }

        // Decoder for ClockDifference
        Decoders.addDecoder(clazz: ClockDifference.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ClockDifference> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ClockDifference() : instance as! ClockDifference
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["diff"] as AnyObject?) {
                
                case let .success(value): _result.diff = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ClockDifference", actual: "\(source)"))
            }
        }
        // Decoder for [ComputerSet]
        Decoders.addDecoder(clazz: [ComputerSet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ComputerSet]> in
            return Decoders.decode(clazz: [ComputerSet].self, source: source)
        }

        // Decoder for ComputerSet
        Decoders.addDecoder(clazz: ComputerSet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ComputerSet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ComputerSet() : instance as! ComputerSet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["busyExecutors"] as AnyObject?) {
                
                case let .success(value): _result.busyExecutors = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [HudsonMasterComputer].self, source: sourceDictionary["computer"] as AnyObject?) {
                
                case let .success(value): _result.computer = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["displayName"] as AnyObject?) {
                
                case let .success(value): _result.displayName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalExecutors"] as AnyObject?) {
                
                case let .success(value): _result.totalExecutors = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ComputerSet", actual: "\(source)"))
            }
        }
        // Decoder for [DefaultCrumbIssuer]
        Decoders.addDecoder(clazz: [DefaultCrumbIssuer].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DefaultCrumbIssuer]> in
            return Decoders.decode(clazz: [DefaultCrumbIssuer].self, source: source)
        }

        // Decoder for DefaultCrumbIssuer
        Decoders.addDecoder(clazz: DefaultCrumbIssuer.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DefaultCrumbIssuer> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DefaultCrumbIssuer() : instance as! DefaultCrumbIssuer
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["crumb"] as AnyObject?) {
                
                case let .success(value): _result.crumb = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["crumbRequestField"] as AnyObject?) {
                
                case let .success(value): _result.crumbRequestField = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DefaultCrumbIssuer", actual: "\(source)"))
            }
        }
        // Decoder for [DiskSpaceMonitorDescriptorDiskSpace]
        Decoders.addDecoder(clazz: [DiskSpaceMonitorDescriptorDiskSpace].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DiskSpaceMonitorDescriptorDiskSpace]> in
            return Decoders.decode(clazz: [DiskSpaceMonitorDescriptorDiskSpace].self, source: source)
        }

        // Decoder for DiskSpaceMonitorDescriptorDiskSpace
        Decoders.addDecoder(clazz: DiskSpaceMonitorDescriptorDiskSpace.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DiskSpaceMonitorDescriptorDiskSpace> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DiskSpaceMonitorDescriptorDiskSpace() : instance as! DiskSpaceMonitorDescriptorDiskSpace
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["timestamp"] as AnyObject?) {
                
                case let .success(value): _result.timestamp = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["path"] as AnyObject?) {
                
                case let .success(value): _result.path = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): _result.size = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DiskSpaceMonitorDescriptorDiskSpace", actual: "\(source)"))
            }
        }
        // Decoder for [EmptyChangeLogSet]
        Decoders.addDecoder(clazz: [EmptyChangeLogSet].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EmptyChangeLogSet]> in
            return Decoders.decode(clazz: [EmptyChangeLogSet].self, source: source)
        }

        // Decoder for EmptyChangeLogSet
        Decoders.addDecoder(clazz: EmptyChangeLogSet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EmptyChangeLogSet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EmptyChangeLogSet() : instance as! EmptyChangeLogSet
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["kind"] as AnyObject?) {
                
                case let .success(value): _result.kind = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EmptyChangeLogSet", actual: "\(source)"))
            }
        }
        // Decoder for [ExtensionClassContainerImpl1]
        Decoders.addDecoder(clazz: [ExtensionClassContainerImpl1].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ExtensionClassContainerImpl1]> in
            return Decoders.decode(clazz: [ExtensionClassContainerImpl1].self, source: source)
        }

        // Decoder for ExtensionClassContainerImpl1
        Decoders.addDecoder(clazz: ExtensionClassContainerImpl1.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ExtensionClassContainerImpl1> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ExtensionClassContainerImpl1() : instance as! ExtensionClassContainerImpl1
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ExtensionClassContainerImpl1links.self, source: sourceDictionary["_links"] as AnyObject?) {
                
                case let .success(value): _result.links = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ExtensionClassContainerImpl1map.self, source: sourceDictionary["map"] as AnyObject?) {
                
                case let .success(value): _result.map = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ExtensionClassContainerImpl1", actual: "\(source)"))
            }
        }
        // Decoder for [ExtensionClassContainerImpl1links]
        Decoders.addDecoder(clazz: [ExtensionClassContainerImpl1links].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ExtensionClassContainerImpl1links]> in
            return Decoders.decode(clazz: [ExtensionClassContainerImpl1links].self, source: source)
        }

        // Decoder for ExtensionClassContainerImpl1links
        Decoders.addDecoder(clazz: ExtensionClassContainerImpl1links.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ExtensionClassContainerImpl1links> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ExtensionClassContainerImpl1links() : instance as! ExtensionClassContainerImpl1links
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["self"] as AnyObject?) {
                
                case let .success(value): _result._self = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ExtensionClassContainerImpl1links", actual: "\(source)"))
            }
        }
        // Decoder for [ExtensionClassContainerImpl1map]
        Decoders.addDecoder(clazz: [ExtensionClassContainerImpl1map].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ExtensionClassContainerImpl1map]> in
            return Decoders.decode(clazz: [ExtensionClassContainerImpl1map].self, source: source)
        }

        // Decoder for ExtensionClassContainerImpl1map
        Decoders.addDecoder(clazz: ExtensionClassContainerImpl1map.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ExtensionClassContainerImpl1map> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ExtensionClassContainerImpl1map() : instance as! ExtensionClassContainerImpl1map
                switch Decoders.decodeOptional(clazz: ExtensionClassImpl.self, source: sourceDictionary["io.jenkins.blueocean.service.embedded.rest.PipelineImpl"] as AnyObject?) {
                
                case let .success(value): _result.ioJenkinsBlueoceanServiceEmbeddedRestPipelineImpl = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ExtensionClassImpl.self, source: sourceDictionary["io.jenkins.blueocean.service.embedded.rest.MultiBranchPipelineImpl"] as AnyObject?) {
                
                case let .success(value): _result.ioJenkinsBlueoceanServiceEmbeddedRestMultiBranchPipelineImpl = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ExtensionClassContainerImpl1map", actual: "\(source)"))
            }
        }
        // Decoder for [ExtensionClassImpl]
        Decoders.addDecoder(clazz: [ExtensionClassImpl].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ExtensionClassImpl]> in
            return Decoders.decode(clazz: [ExtensionClassImpl].self, source: source)
        }

        // Decoder for ExtensionClassImpl
        Decoders.addDecoder(clazz: ExtensionClassImpl.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ExtensionClassImpl> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ExtensionClassImpl() : instance as! ExtensionClassImpl
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ExtensionClassImpllinks.self, source: sourceDictionary["_links"] as AnyObject?) {
                
                case let .success(value): _result.links = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["classes"] as AnyObject?) {
                
                case let .success(value): _result.classes = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ExtensionClassImpl", actual: "\(source)"))
            }
        }
        // Decoder for [ExtensionClassImpllinks]
        Decoders.addDecoder(clazz: [ExtensionClassImpllinks].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ExtensionClassImpllinks]> in
            return Decoders.decode(clazz: [ExtensionClassImpllinks].self, source: source)
        }

        // Decoder for ExtensionClassImpllinks
        Decoders.addDecoder(clazz: ExtensionClassImpllinks.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ExtensionClassImpllinks> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ExtensionClassImpllinks() : instance as! ExtensionClassImpllinks
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["self"] as AnyObject?) {
                
                case let .success(value): _result._self = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ExtensionClassImpllinks", actual: "\(source)"))
            }
        }
        // Decoder for [FavoriteImpl]
        Decoders.addDecoder(clazz: [FavoriteImpl].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FavoriteImpl]> in
            return Decoders.decode(clazz: [FavoriteImpl].self, source: source)
        }

        // Decoder for FavoriteImpl
        Decoders.addDecoder(clazz: FavoriteImpl.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FavoriteImpl> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FavoriteImpl() : instance as! FavoriteImpl
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: FavoriteImpllinks.self, source: sourceDictionary["_links"] as AnyObject?) {
                
                case let .success(value): _result.links = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: PipelineImpl.self, source: sourceDictionary["item"] as AnyObject?) {
                
                case let .success(value): _result.item = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FavoriteImpl", actual: "\(source)"))
            }
        }
        // Decoder for [FavoriteImpllinks]
        Decoders.addDecoder(clazz: [FavoriteImpllinks].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FavoriteImpllinks]> in
            return Decoders.decode(clazz: [FavoriteImpllinks].self, source: source)
        }

        // Decoder for FavoriteImpllinks
        Decoders.addDecoder(clazz: FavoriteImpllinks.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FavoriteImpllinks> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FavoriteImpllinks() : instance as! FavoriteImpllinks
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["self"] as AnyObject?) {
                
                case let .success(value): _result._self = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FavoriteImpllinks", actual: "\(source)"))
            }
        }
        // Decoder for [FreeStyleBuild]
        Decoders.addDecoder(clazz: [FreeStyleBuild].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FreeStyleBuild]> in
            return Decoders.decode(clazz: [FreeStyleBuild].self, source: source)
        }

        // Decoder for FreeStyleBuild
        Decoders.addDecoder(clazz: FreeStyleBuild.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FreeStyleBuild> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FreeStyleBuild() : instance as! FreeStyleBuild
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): _result.number = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["url"] as AnyObject?) {
                
                case let .success(value): _result.url = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [CauseAction].self, source: sourceDictionary["actions"] as AnyObject?) {
                
                case let .success(value): _result.actions = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["building"] as AnyObject?) {
                
                case let .success(value): _result.building = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): _result.description = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["displayName"] as AnyObject?) {
                
                case let .success(value): _result.displayName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["duration"] as AnyObject?) {
                
                case let .success(value): _result.duration = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["estimatedDuration"] as AnyObject?) {
                
                case let .success(value): _result.estimatedDuration = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["executor"] as AnyObject?) {
                
                case let .success(value): _result.executor = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fullDisplayName"] as AnyObject?) {
                
                case let .success(value): _result.fullDisplayName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["keepLog"] as AnyObject?) {
                
                case let .success(value): _result.keepLog = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["queueId"] as AnyObject?) {
                
                case let .success(value): _result.queueId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["result"] as AnyObject?) {
                
                case let .success(value): _result.result = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["timestamp"] as AnyObject?) {
                
                case let .success(value): _result.timestamp = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["builtOn"] as AnyObject?) {
                
                case let .success(value): _result.builtOn = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: EmptyChangeLogSet.self, source: sourceDictionary["changeSet"] as AnyObject?) {
                
                case let .success(value): _result.changeSet = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FreeStyleBuild", actual: "\(source)"))
            }
        }
        // Decoder for [FreeStyleProject]
        Decoders.addDecoder(clazz: [FreeStyleProject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FreeStyleProject]> in
            return Decoders.decode(clazz: [FreeStyleProject].self, source: source)
        }

        // Decoder for FreeStyleProject
        Decoders.addDecoder(clazz: FreeStyleProject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FreeStyleProject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FreeStyleProject() : instance as! FreeStyleProject
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["url"] as AnyObject?) {
                
                case let .success(value): _result.url = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["color"] as AnyObject?) {
                
                case let .success(value): _result.color = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [FreeStyleProjectactions].self, source: sourceDictionary["actions"] as AnyObject?) {
                
                case let .success(value): _result.actions = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): _result.description = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["displayName"] as AnyObject?) {
                
                case let .success(value): _result.displayName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["displayNameOrNull"] as AnyObject?) {
                
                case let .success(value): _result.displayNameOrNull = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fullDisplayName"] as AnyObject?) {
                
                case let .success(value): _result.fullDisplayName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fullName"] as AnyObject?) {
                
                case let .success(value): _result.fullName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["buildable"] as AnyObject?) {
                
                case let .success(value): _result.buildable = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [FreeStyleBuild].self, source: sourceDictionary["builds"] as AnyObject?) {
                
                case let .success(value): _result.builds = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: FreeStyleBuild.self, source: sourceDictionary["firstBuild"] as AnyObject?) {
                
                case let .success(value): _result.firstBuild = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [FreeStyleProjecthealthReport].self, source: sourceDictionary["healthReport"] as AnyObject?) {
                
                case let .success(value): _result.healthReport = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["inQueue"] as AnyObject?) {
                
                case let .success(value): _result.inQueue = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["keepDependencies"] as AnyObject?) {
                
                case let .success(value): _result.keepDependencies = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: FreeStyleBuild.self, source: sourceDictionary["lastBuild"] as AnyObject?) {
                
                case let .success(value): _result.lastBuild = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: FreeStyleBuild.self, source: sourceDictionary["lastCompletedBuild"] as AnyObject?) {
                
                case let .success(value): _result.lastCompletedBuild = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["lastFailedBuild"] as AnyObject?) {
                
                case let .success(value): _result.lastFailedBuild = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: FreeStyleBuild.self, source: sourceDictionary["lastStableBuild"] as AnyObject?) {
                
                case let .success(value): _result.lastStableBuild = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: FreeStyleBuild.self, source: sourceDictionary["lastSuccessfulBuild"] as AnyObject?) {
                
                case let .success(value): _result.lastSuccessfulBuild = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["lastUnstableBuild"] as AnyObject?) {
                
                case let .success(value): _result.lastUnstableBuild = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["lastUnsuccessfulBuild"] as AnyObject?) {
                
                case let .success(value): _result.lastUnsuccessfulBuild = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["nextBuildNumber"] as AnyObject?) {
                
                case let .success(value): _result.nextBuildNumber = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["queueItem"] as AnyObject?) {
                
                case let .success(value): _result.queueItem = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["concurrentBuild"] as AnyObject?) {
                
                case let .success(value): _result.concurrentBuild = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: NullSCM.self, source: sourceDictionary["scm"] as AnyObject?) {
                
                case let .success(value): _result.scm = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FreeStyleProject", actual: "\(source)"))
            }
        }
        // Decoder for [FreeStyleProjectactions]
        Decoders.addDecoder(clazz: [FreeStyleProjectactions].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FreeStyleProjectactions]> in
            return Decoders.decode(clazz: [FreeStyleProjectactions].self, source: source)
        }

        // Decoder for FreeStyleProjectactions
        Decoders.addDecoder(clazz: FreeStyleProjectactions.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FreeStyleProjectactions> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FreeStyleProjectactions() : instance as! FreeStyleProjectactions
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FreeStyleProjectactions", actual: "\(source)"))
            }
        }
        // Decoder for [FreeStyleProjecthealthReport]
        Decoders.addDecoder(clazz: [FreeStyleProjecthealthReport].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FreeStyleProjecthealthReport]> in
            return Decoders.decode(clazz: [FreeStyleProjecthealthReport].self, source: source)
        }

        // Decoder for FreeStyleProjecthealthReport
        Decoders.addDecoder(clazz: FreeStyleProjecthealthReport.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FreeStyleProjecthealthReport> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FreeStyleProjecthealthReport() : instance as! FreeStyleProjecthealthReport
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): _result.description = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["iconClassName"] as AnyObject?) {
                
                case let .success(value): _result.iconClassName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["iconUrl"] as AnyObject?) {
                
                case let .success(value): _result.iconUrl = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["score"] as AnyObject?) {
                
                case let .success(value): _result.score = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FreeStyleProjecthealthReport", actual: "\(source)"))
            }
        }
        // Decoder for [GenericResource]
        Decoders.addDecoder(clazz: [GenericResource].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[GenericResource]> in
            return Decoders.decode(clazz: [GenericResource].self, source: source)
        }

        // Decoder for GenericResource
        Decoders.addDecoder(clazz: GenericResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GenericResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? GenericResource() : instance as! GenericResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["displayName"] as AnyObject?) {
                
                case let .success(value): _result.displayName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["durationInMillis"] as AnyObject?) {
                
                case let .success(value): _result.durationInMillis = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["result"] as AnyObject?) {
                
                case let .success(value): _result.result = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["startTime"] as AnyObject?) {
                
                case let .success(value): _result.startTime = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "GenericResource", actual: "\(source)"))
            }
        }
        // Decoder for [GithubContent]
        Decoders.addDecoder(clazz: [GithubContent].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[GithubContent]> in
            return Decoders.decode(clazz: [GithubContent].self, source: source)
        }

        // Decoder for GithubContent
        Decoders.addDecoder(clazz: GithubContent.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GithubContent> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? GithubContent() : instance as! GithubContent
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sha"] as AnyObject?) {
                
                case let .success(value): _result.sha = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["repo"] as AnyObject?) {
                
                case let .success(value): _result.repo = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): _result.size = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["owner"] as AnyObject?) {
                
                case let .success(value): _result.owner = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["path"] as AnyObject?) {
                
                case let .success(value): _result.path = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["base64Data"] as AnyObject?) {
                
                case let .success(value): _result.base64Data = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "GithubContent", actual: "\(source)"))
            }
        }
        // Decoder for [GithubFile]
        Decoders.addDecoder(clazz: [GithubFile].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[GithubFile]> in
            return Decoders.decode(clazz: [GithubFile].self, source: source)
        }

        // Decoder for GithubFile
        Decoders.addDecoder(clazz: GithubFile.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GithubFile> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? GithubFile() : instance as! GithubFile
                switch Decoders.decodeOptional(clazz: GithubContent.self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): _result.content = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "GithubFile", actual: "\(source)"))
            }
        }
        // Decoder for [GithubOrganization]
        Decoders.addDecoder(clazz: [GithubOrganization].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[GithubOrganization]> in
            return Decoders.decode(clazz: [GithubOrganization].self, source: source)
        }

        // Decoder for GithubOrganization
        Decoders.addDecoder(clazz: GithubOrganization.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GithubOrganization> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? GithubOrganization() : instance as! GithubOrganization
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: GithubOrganizationlinks.self, source: sourceDictionary["_links"] as AnyObject?) {
                
                case let .success(value): _result.links = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["jenkinsOrganizationPipeline"] as AnyObject?) {
                
                case let .success(value): _result.jenkinsOrganizationPipeline = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "GithubOrganization", actual: "\(source)"))
            }
        }
        // Decoder for [GithubOrganizationlinks]
        Decoders.addDecoder(clazz: [GithubOrganizationlinks].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[GithubOrganizationlinks]> in
            return Decoders.decode(clazz: [GithubOrganizationlinks].self, source: source)
        }

        // Decoder for GithubOrganizationlinks
        Decoders.addDecoder(clazz: GithubOrganizationlinks.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GithubOrganizationlinks> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? GithubOrganizationlinks() : instance as! GithubOrganizationlinks
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["repositories"] as AnyObject?) {
                
                case let .success(value): _result.repositories = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["self"] as AnyObject?) {
                
                case let .success(value): _result._self = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "GithubOrganizationlinks", actual: "\(source)"))
            }
        }
        // Decoder for [GithubRepositories]
        Decoders.addDecoder(clazz: [GithubRepositories].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[GithubRepositories]> in
            return Decoders.decode(clazz: [GithubRepositories].self, source: source)
        }

        // Decoder for GithubRepositories
        Decoders.addDecoder(clazz: GithubRepositories.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GithubRepositories> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? GithubRepositories() : instance as! GithubRepositories
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: GithubRepositorieslinks.self, source: sourceDictionary["_links"] as AnyObject?) {
                
                case let .success(value): _result.links = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [GithubRepository].self, source: sourceDictionary["items"] as AnyObject?) {
                
                case let .success(value): _result.items = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["lastPage"] as AnyObject?) {
                
                case let .success(value): _result.lastPage = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["nextPage"] as AnyObject?) {
                
                case let .success(value): _result.nextPage = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pageSize"] as AnyObject?) {
                
                case let .success(value): _result.pageSize = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "GithubRepositories", actual: "\(source)"))
            }
        }
        // Decoder for [GithubRepositorieslinks]
        Decoders.addDecoder(clazz: [GithubRepositorieslinks].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[GithubRepositorieslinks]> in
            return Decoders.decode(clazz: [GithubRepositorieslinks].self, source: source)
        }

        // Decoder for GithubRepositorieslinks
        Decoders.addDecoder(clazz: GithubRepositorieslinks.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GithubRepositorieslinks> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? GithubRepositorieslinks() : instance as! GithubRepositorieslinks
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["self"] as AnyObject?) {
                
                case let .success(value): _result._self = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "GithubRepositorieslinks", actual: "\(source)"))
            }
        }
        // Decoder for [GithubRepository]
        Decoders.addDecoder(clazz: [GithubRepository].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[GithubRepository]> in
            return Decoders.decode(clazz: [GithubRepository].self, source: source)
        }

        // Decoder for GithubRepository
        Decoders.addDecoder(clazz: GithubRepository.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GithubRepository> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? GithubRepository() : instance as! GithubRepository
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: GithubRepositorylinks.self, source: sourceDictionary["_links"] as AnyObject?) {
                
                case let .success(value): _result.links = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["defaultBranch"] as AnyObject?) {
                
                case let .success(value): _result.defaultBranch = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): _result.description = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: GithubRepositorypermissions.self, source: sourceDictionary["permissions"] as AnyObject?) {
                
                case let .success(value): _result.permissions = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["private"] as AnyObject?) {
                
                case let .success(value): _result._private = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fullName"] as AnyObject?) {
                
                case let .success(value): _result.fullName = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "GithubRepository", actual: "\(source)"))
            }
        }
        // Decoder for [GithubRepositorylinks]
        Decoders.addDecoder(clazz: [GithubRepositorylinks].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[GithubRepositorylinks]> in
            return Decoders.decode(clazz: [GithubRepositorylinks].self, source: source)
        }

        // Decoder for GithubRepositorylinks
        Decoders.addDecoder(clazz: GithubRepositorylinks.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GithubRepositorylinks> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? GithubRepositorylinks() : instance as! GithubRepositorylinks
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["self"] as AnyObject?) {
                
                case let .success(value): _result._self = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "GithubRepositorylinks", actual: "\(source)"))
            }
        }
        // Decoder for [GithubRepositorypermissions]
        Decoders.addDecoder(clazz: [GithubRepositorypermissions].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[GithubRepositorypermissions]> in
            return Decoders.decode(clazz: [GithubRepositorypermissions].self, source: source)
        }

        // Decoder for GithubRepositorypermissions
        Decoders.addDecoder(clazz: GithubRepositorypermissions.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GithubRepositorypermissions> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? GithubRepositorypermissions() : instance as! GithubRepositorypermissions
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["admin"] as AnyObject?) {
                
                case let .success(value): _result.admin = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["push"] as AnyObject?) {
                
                case let .success(value): _result.push = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["pull"] as AnyObject?) {
                
                case let .success(value): _result.pull = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "GithubRepositorypermissions", actual: "\(source)"))
            }
        }
        // Decoder for [GithubRespositoryContainer]
        Decoders.addDecoder(clazz: [GithubRespositoryContainer].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[GithubRespositoryContainer]> in
            return Decoders.decode(clazz: [GithubRespositoryContainer].self, source: source)
        }

        // Decoder for GithubRespositoryContainer
        Decoders.addDecoder(clazz: GithubRespositoryContainer.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GithubRespositoryContainer> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? GithubRespositoryContainer() : instance as! GithubRespositoryContainer
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: GithubRespositoryContainerlinks.self, source: sourceDictionary["_links"] as AnyObject?) {
                
                case let .success(value): _result.links = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: GithubRepositories.self, source: sourceDictionary["repositories"] as AnyObject?) {
                
                case let .success(value): _result.repositories = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "GithubRespositoryContainer", actual: "\(source)"))
            }
        }
        // Decoder for [GithubRespositoryContainerlinks]
        Decoders.addDecoder(clazz: [GithubRespositoryContainerlinks].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[GithubRespositoryContainerlinks]> in
            return Decoders.decode(clazz: [GithubRespositoryContainerlinks].self, source: source)
        }

        // Decoder for GithubRespositoryContainerlinks
        Decoders.addDecoder(clazz: GithubRespositoryContainerlinks.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GithubRespositoryContainerlinks> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? GithubRespositoryContainerlinks() : instance as! GithubRespositoryContainerlinks
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["self"] as AnyObject?) {
                
                case let .success(value): _result._self = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "GithubRespositoryContainerlinks", actual: "\(source)"))
            }
        }
        // Decoder for [GithubScm]
        Decoders.addDecoder(clazz: [GithubScm].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[GithubScm]> in
            return Decoders.decode(clazz: [GithubScm].self, source: source)
        }

        // Decoder for GithubScm
        Decoders.addDecoder(clazz: GithubScm.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GithubScm> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? GithubScm() : instance as! GithubScm
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: GithubScmlinks.self, source: sourceDictionary["_links"] as AnyObject?) {
                
                case let .success(value): _result.links = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["credentialId"] as AnyObject?) {
                
                case let .success(value): _result.credentialId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uri"] as AnyObject?) {
                
                case let .success(value): _result.uri = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "GithubScm", actual: "\(source)"))
            }
        }
        // Decoder for [GithubScmlinks]
        Decoders.addDecoder(clazz: [GithubScmlinks].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[GithubScmlinks]> in
            return Decoders.decode(clazz: [GithubScmlinks].self, source: source)
        }

        // Decoder for GithubScmlinks
        Decoders.addDecoder(clazz: GithubScmlinks.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GithubScmlinks> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? GithubScmlinks() : instance as! GithubScmlinks
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["self"] as AnyObject?) {
                
                case let .success(value): _result._self = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "GithubScmlinks", actual: "\(source)"))
            }
        }
        // Decoder for [Hudson]
        Decoders.addDecoder(clazz: [Hudson].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Hudson]> in
            return Decoders.decode(clazz: [Hudson].self, source: source)
        }

        // Decoder for Hudson
        Decoders.addDecoder(clazz: Hudson.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Hudson> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Hudson() : instance as! Hudson
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [HudsonassignedLabels].self, source: sourceDictionary["assignedLabels"] as AnyObject?) {
                
                case let .success(value): _result.assignedLabels = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["mode"] as AnyObject?) {
                
                case let .success(value): _result.mode = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["nodeDescription"] as AnyObject?) {
                
                case let .success(value): _result.nodeDescription = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["nodeName"] as AnyObject?) {
                
                case let .success(value): _result.nodeName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["numExecutors"] as AnyObject?) {
                
                case let .success(value): _result.numExecutors = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): _result.description = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [FreeStyleProject].self, source: sourceDictionary["jobs"] as AnyObject?) {
                
                case let .success(value): _result.jobs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: AllView.self, source: sourceDictionary["primaryView"] as AnyObject?) {
                
                case let .success(value): _result.primaryView = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["quietingDown"] as AnyObject?) {
                
                case let .success(value): _result.quietingDown = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["slaveAgentPort"] as AnyObject?) {
                
                case let .success(value): _result.slaveAgentPort = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: UnlabeledLoadStatistics.self, source: sourceDictionary["unlabeledLoad"] as AnyObject?) {
                
                case let .success(value): _result.unlabeledLoad = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["useCrumbs"] as AnyObject?) {
                
                case let .success(value): _result.useCrumbs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["useSecurity"] as AnyObject?) {
                
                case let .success(value): _result.useSecurity = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [AllView].self, source: sourceDictionary["views"] as AnyObject?) {
                
                case let .success(value): _result.views = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Hudson", actual: "\(source)"))
            }
        }
        // Decoder for [HudsonMasterComputer]
        Decoders.addDecoder(clazz: [HudsonMasterComputer].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[HudsonMasterComputer]> in
            return Decoders.decode(clazz: [HudsonMasterComputer].self, source: source)
        }

        // Decoder for HudsonMasterComputer
        Decoders.addDecoder(clazz: HudsonMasterComputer.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<HudsonMasterComputer> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? HudsonMasterComputer() : instance as! HudsonMasterComputer
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["displayName"] as AnyObject?) {
                
                case let .success(value): _result.displayName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [HudsonMasterComputerexecutors].self, source: sourceDictionary["executors"] as AnyObject?) {
                
                case let .success(value): _result.executors = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["icon"] as AnyObject?) {
                
                case let .success(value): _result.icon = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["iconClassName"] as AnyObject?) {
                
                case let .success(value): _result.iconClassName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["idle"] as AnyObject?) {
                
                case let .success(value): _result.idle = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["jnlpAgent"] as AnyObject?) {
                
                case let .success(value): _result.jnlpAgent = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["launchSupported"] as AnyObject?) {
                
                case let .success(value): _result.launchSupported = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Label1.self, source: sourceDictionary["loadStatistics"] as AnyObject?) {
                
                case let .success(value): _result.loadStatistics = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["manualLaunchAllowed"] as AnyObject?) {
                
                case let .success(value): _result.manualLaunchAllowed = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: HudsonMasterComputermonitorData.self, source: sourceDictionary["monitorData"] as AnyObject?) {
                
                case let .success(value): _result.monitorData = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["numExecutors"] as AnyObject?) {
                
                case let .success(value): _result.numExecutors = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["offline"] as AnyObject?) {
                
                case let .success(value): _result.offline = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["offlineCause"] as AnyObject?) {
                
                case let .success(value): _result.offlineCause = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["offlineCauseReason"] as AnyObject?) {
                
                case let .success(value): _result.offlineCauseReason = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["temporarilyOffline"] as AnyObject?) {
                
                case let .success(value): _result.temporarilyOffline = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "HudsonMasterComputer", actual: "\(source)"))
            }
        }
        // Decoder for [HudsonMasterComputerexecutors]
        Decoders.addDecoder(clazz: [HudsonMasterComputerexecutors].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[HudsonMasterComputerexecutors]> in
            return Decoders.decode(clazz: [HudsonMasterComputerexecutors].self, source: source)
        }

        // Decoder for HudsonMasterComputerexecutors
        Decoders.addDecoder(clazz: HudsonMasterComputerexecutors.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<HudsonMasterComputerexecutors> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? HudsonMasterComputerexecutors() : instance as! HudsonMasterComputerexecutors
                switch Decoders.decodeOptional(clazz: FreeStyleBuild.self, source: sourceDictionary["currentExecutable"] as AnyObject?) {
                
                case let .success(value): _result.currentExecutable = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["idle"] as AnyObject?) {
                
                case let .success(value): _result.idle = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["likelyStuck"] as AnyObject?) {
                
                case let .success(value): _result.likelyStuck = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): _result.number = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["progress"] as AnyObject?) {
                
                case let .success(value): _result.progress = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "HudsonMasterComputerexecutors", actual: "\(source)"))
            }
        }
        // Decoder for [HudsonMasterComputermonitorData]
        Decoders.addDecoder(clazz: [HudsonMasterComputermonitorData].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[HudsonMasterComputermonitorData]> in
            return Decoders.decode(clazz: [HudsonMasterComputermonitorData].self, source: source)
        }

        // Decoder for HudsonMasterComputermonitorData
        Decoders.addDecoder(clazz: HudsonMasterComputermonitorData.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<HudsonMasterComputermonitorData> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? HudsonMasterComputermonitorData() : instance as! HudsonMasterComputermonitorData
                switch Decoders.decodeOptional(clazz: SwapSpaceMonitorMemoryUsage2.self, source: sourceDictionary["hudson.node_monitors.SwapSpaceMonitor"] as AnyObject?) {
                
                case let .success(value): _result.hudsonNodeMonitorsSwapSpaceMonitor = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: DiskSpaceMonitorDescriptorDiskSpace.self, source: sourceDictionary["hudson.node_monitors.TemporarySpaceMonitor"] as AnyObject?) {
                
                case let .success(value): _result.hudsonNodeMonitorsTemporarySpaceMonitor = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: DiskSpaceMonitorDescriptorDiskSpace.self, source: sourceDictionary["hudson.node_monitors.DiskSpaceMonitor"] as AnyObject?) {
                
                case let .success(value): _result.hudsonNodeMonitorsDiskSpaceMonitor = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hudson.node_monitors.ArchitectureMonitor"] as AnyObject?) {
                
                case let .success(value): _result.hudsonNodeMonitorsArchitectureMonitor = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ResponseTimeMonitorData.self, source: sourceDictionary["hudson.node_monitors.ResponseTimeMonitor"] as AnyObject?) {
                
                case let .success(value): _result.hudsonNodeMonitorsResponseTimeMonitor = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ClockDifference.self, source: sourceDictionary["hudson.node_monitors.ClockMonitor"] as AnyObject?) {
                
                case let .success(value): _result.hudsonNodeMonitorsClockMonitor = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "HudsonMasterComputermonitorData", actual: "\(source)"))
            }
        }
        // Decoder for [HudsonassignedLabels]
        Decoders.addDecoder(clazz: [HudsonassignedLabels].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[HudsonassignedLabels]> in
            return Decoders.decode(clazz: [HudsonassignedLabels].self, source: source)
        }

        // Decoder for HudsonassignedLabels
        Decoders.addDecoder(clazz: HudsonassignedLabels.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<HudsonassignedLabels> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? HudsonassignedLabels() : instance as! HudsonassignedLabels
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "HudsonassignedLabels", actual: "\(source)"))
            }
        }
        // Decoder for [InputStepImpl]
        Decoders.addDecoder(clazz: [InputStepImpl].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InputStepImpl]> in
            return Decoders.decode(clazz: [InputStepImpl].self, source: source)
        }

        // Decoder for InputStepImpl
        Decoders.addDecoder(clazz: InputStepImpl.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InputStepImpl> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InputStepImpl() : instance as! InputStepImpl
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: InputStepImpllinks.self, source: sourceDictionary["_links"] as AnyObject?) {
                
                case let .success(value): _result.links = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["ok"] as AnyObject?) {
                
                case let .success(value): _result.ok = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [StringParameterDefinition].self, source: sourceDictionary["parameters"] as AnyObject?) {
                
                case let .success(value): _result.parameters = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["submitter"] as AnyObject?) {
                
                case let .success(value): _result.submitter = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InputStepImpl", actual: "\(source)"))
            }
        }
        // Decoder for [InputStepImpllinks]
        Decoders.addDecoder(clazz: [InputStepImpllinks].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InputStepImpllinks]> in
            return Decoders.decode(clazz: [InputStepImpllinks].self, source: source)
        }

        // Decoder for InputStepImpllinks
        Decoders.addDecoder(clazz: InputStepImpllinks.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InputStepImpllinks> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InputStepImpllinks() : instance as! InputStepImpllinks
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["self"] as AnyObject?) {
                
                case let .success(value): _result._self = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InputStepImpllinks", actual: "\(source)"))
            }
        }
        // Decoder for [Label1]
        Decoders.addDecoder(clazz: [Label1].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Label1]> in
            return Decoders.decode(clazz: [Label1].self, source: source)
        }

        // Decoder for Label1
        Decoders.addDecoder(clazz: Label1.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Label1> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Label1() : instance as! Label1
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Label1", actual: "\(source)"))
            }
        }
        // Decoder for [Link]
        Decoders.addDecoder(clazz: [Link].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Link]> in
            return Decoders.decode(clazz: [Link].self, source: source)
        }

        // Decoder for Link
        Decoders.addDecoder(clazz: Link.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Link> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Link() : instance as! Link
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["href"] as AnyObject?) {
                
                case let .success(value): _result.href = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Link", actual: "\(source)"))
            }
        }
        // Decoder for [ListView]
        Decoders.addDecoder(clazz: [ListView].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ListView]> in
            return Decoders.decode(clazz: [ListView].self, source: source)
        }

        // Decoder for ListView
        Decoders.addDecoder(clazz: ListView.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ListView> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ListView() : instance as! ListView
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): _result.description = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [FreeStyleProject].self, source: sourceDictionary["jobs"] as AnyObject?) {
                
                case let .success(value): _result.jobs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["url"] as AnyObject?) {
                
                case let .success(value): _result.url = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ListView", actual: "\(source)"))
            }
        }
        // Decoder for [MultibranchPipeline]
        Decoders.addDecoder(clazz: [MultibranchPipeline].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[MultibranchPipeline]> in
            return Decoders.decode(clazz: [MultibranchPipeline].self, source: source)
        }

        // Decoder for MultibranchPipeline
        Decoders.addDecoder(clazz: MultibranchPipeline.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<MultibranchPipeline> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? MultibranchPipeline() : instance as! MultibranchPipeline
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["displayName"] as AnyObject?) {
                
                case let .success(value): _result.displayName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["estimatedDurationInMillis"] as AnyObject?) {
                
                case let .success(value): _result.estimatedDurationInMillis = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latestRun"] as AnyObject?) {
                
                case let .success(value): _result.latestRun = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["organization"] as AnyObject?) {
                
                case let .success(value): _result.organization = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["weatherScore"] as AnyObject?) {
                
                case let .success(value): _result.weatherScore = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["branchNames"] as AnyObject?) {
                
                case let .success(value): _result.branchNames = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["numberOfFailingBranches"] as AnyObject?) {
                
                case let .success(value): _result.numberOfFailingBranches = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["numberOfFailingPullRequests"] as AnyObject?) {
                
                case let .success(value): _result.numberOfFailingPullRequests = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["numberOfSuccessfulBranches"] as AnyObject?) {
                
                case let .success(value): _result.numberOfSuccessfulBranches = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["numberOfSuccessfulPullRequests"] as AnyObject?) {
                
                case let .success(value): _result.numberOfSuccessfulPullRequests = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalNumberOfBranches"] as AnyObject?) {
                
                case let .success(value): _result.totalNumberOfBranches = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalNumberOfPullRequests"] as AnyObject?) {
                
                case let .success(value): _result.totalNumberOfPullRequests = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "MultibranchPipeline", actual: "\(source)"))
            }
        }
        // Decoder for [NullSCM]
        Decoders.addDecoder(clazz: [NullSCM].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[NullSCM]> in
            return Decoders.decode(clazz: [NullSCM].self, source: source)
        }

        // Decoder for NullSCM
        Decoders.addDecoder(clazz: NullSCM.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<NullSCM> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? NullSCM() : instance as! NullSCM
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "NullSCM", actual: "\(source)"))
            }
        }
        // Decoder for [Organisation]
        Decoders.addDecoder(clazz: [Organisation].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Organisation]> in
            return Decoders.decode(clazz: [Organisation].self, source: source)
        }

        // Decoder for Organisation
        Decoders.addDecoder(clazz: Organisation.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Organisation> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Organisation() : instance as! Organisation
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Organisation", actual: "\(source)"))
            }
        }
        // Decoder for [Pipeline]
        Decoders.addDecoder(clazz: [Pipeline].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Pipeline]> in
            return Decoders.decode(clazz: [Pipeline].self, source: source)
        }

        // Decoder for Pipeline
        Decoders.addDecoder(clazz: Pipeline.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Pipeline> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Pipeline() : instance as! Pipeline
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["organization"] as AnyObject?) {
                
                case let .success(value): _result.organization = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["displayName"] as AnyObject?) {
                
                case let .success(value): _result.displayName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fullName"] as AnyObject?) {
                
                case let .success(value): _result.fullName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["weatherScore"] as AnyObject?) {
                
                case let .success(value): _result.weatherScore = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["estimatedDurationInMillis"] as AnyObject?) {
                
                case let .success(value): _result.estimatedDurationInMillis = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: PipelinelatestRun.self, source: sourceDictionary["latestRun"] as AnyObject?) {
                
                case let .success(value): _result.latestRun = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Pipeline", actual: "\(source)"))
            }
        }
        // Decoder for [PipelineActivity]
        Decoders.addDecoder(clazz: [PipelineActivity].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PipelineActivity]> in
            return Decoders.decode(clazz: [PipelineActivity].self, source: source)
        }

        // Decoder for PipelineActivity
        Decoders.addDecoder(clazz: PipelineActivity.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PipelineActivity> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PipelineActivity() : instance as! PipelineActivity
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [PipelineActivityartifacts].self, source: sourceDictionary["artifacts"] as AnyObject?) {
                
                case let .success(value): _result.artifacts = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["durationInMillis"] as AnyObject?) {
                
                case let .success(value): _result.durationInMillis = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["estimatedDurationInMillis"] as AnyObject?) {
                
                case let .success(value): _result.estimatedDurationInMillis = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["enQueueTime"] as AnyObject?) {
                
                case let .success(value): _result.enQueueTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["endTime"] as AnyObject?) {
                
                case let .success(value): _result.endTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["organization"] as AnyObject?) {
                
                case let .success(value): _result.organization = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["pipeline"] as AnyObject?) {
                
                case let .success(value): _result.pipeline = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["result"] as AnyObject?) {
                
                case let .success(value): _result.result = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["runSummary"] as AnyObject?) {
                
                case let .success(value): _result.runSummary = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["startTime"] as AnyObject?) {
                
                case let .success(value): _result.startTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["state"] as AnyObject?) {
                
                case let .success(value): _result.state = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["commitId"] as AnyObject?) {
                
                case let .success(value): _result.commitId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PipelineActivity", actual: "\(source)"))
            }
        }
        // Decoder for [PipelineActivityartifacts]
        Decoders.addDecoder(clazz: [PipelineActivityartifacts].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PipelineActivityartifacts]> in
            return Decoders.decode(clazz: [PipelineActivityartifacts].self, source: source)
        }

        // Decoder for PipelineActivityartifacts
        Decoders.addDecoder(clazz: PipelineActivityartifacts.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PipelineActivityartifacts> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PipelineActivityartifacts() : instance as! PipelineActivityartifacts
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): _result.size = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["url"] as AnyObject?) {
                
                case let .success(value): _result.url = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PipelineActivityartifacts", actual: "\(source)"))
            }
        }
        // Decoder for [PipelineBranchesitem]
        Decoders.addDecoder(clazz: [PipelineBranchesitem].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PipelineBranchesitem]> in
            return Decoders.decode(clazz: [PipelineBranchesitem].self, source: source)
        }

        // Decoder for PipelineBranchesitem
        Decoders.addDecoder(clazz: PipelineBranchesitem.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PipelineBranchesitem> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PipelineBranchesitem() : instance as! PipelineBranchesitem
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["displayName"] as AnyObject?) {
                
                case let .success(value): _result.displayName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["estimatedDurationInMillis"] as AnyObject?) {
                
                case let .success(value): _result.estimatedDurationInMillis = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["weatherScore"] as AnyObject?) {
                
                case let .success(value): _result.weatherScore = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: PipelineBranchesitemlatestRun.self, source: sourceDictionary["latestRun"] as AnyObject?) {
                
                case let .success(value): _result.latestRun = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["organization"] as AnyObject?) {
                
                case let .success(value): _result.organization = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: PipelineBranchesitempullRequest.self, source: sourceDictionary["pullRequest"] as AnyObject?) {
                
                case let .success(value): _result.pullRequest = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalNumberOfPullRequests"] as AnyObject?) {
                
                case let .success(value): _result.totalNumberOfPullRequests = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PipelineBranchesitem", actual: "\(source)"))
            }
        }
        // Decoder for [PipelineBranchesitemlatestRun]
        Decoders.addDecoder(clazz: [PipelineBranchesitemlatestRun].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PipelineBranchesitemlatestRun]> in
            return Decoders.decode(clazz: [PipelineBranchesitemlatestRun].self, source: source)
        }

        // Decoder for PipelineBranchesitemlatestRun
        Decoders.addDecoder(clazz: PipelineBranchesitemlatestRun.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PipelineBranchesitemlatestRun> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PipelineBranchesitemlatestRun() : instance as! PipelineBranchesitemlatestRun
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["durationInMillis"] as AnyObject?) {
                
                case let .success(value): _result.durationInMillis = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["estimatedDurationInMillis"] as AnyObject?) {
                
                case let .success(value): _result.estimatedDurationInMillis = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["enQueueTime"] as AnyObject?) {
                
                case let .success(value): _result.enQueueTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["endTime"] as AnyObject?) {
                
                case let .success(value): _result.endTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["organization"] as AnyObject?) {
                
                case let .success(value): _result.organization = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["pipeline"] as AnyObject?) {
                
                case let .success(value): _result.pipeline = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["result"] as AnyObject?) {
                
                case let .success(value): _result.result = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["runSummary"] as AnyObject?) {
                
                case let .success(value): _result.runSummary = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["startTime"] as AnyObject?) {
                
                case let .success(value): _result.startTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["state"] as AnyObject?) {
                
                case let .success(value): _result.state = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["commitId"] as AnyObject?) {
                
                case let .success(value): _result.commitId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PipelineBranchesitemlatestRun", actual: "\(source)"))
            }
        }
        // Decoder for [PipelineBranchesitempullRequest]
        Decoders.addDecoder(clazz: [PipelineBranchesitempullRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PipelineBranchesitempullRequest]> in
            return Decoders.decode(clazz: [PipelineBranchesitempullRequest].self, source: source)
        }

        // Decoder for PipelineBranchesitempullRequest
        Decoders.addDecoder(clazz: PipelineBranchesitempullRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PipelineBranchesitempullRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PipelineBranchesitempullRequest() : instance as! PipelineBranchesitempullRequest
                switch Decoders.decodeOptional(clazz: PipelineBranchesitempullRequestlinks.self, source: sourceDictionary["_links"] as AnyObject?) {
                
                case let .success(value): _result.links = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["author"] as AnyObject?) {
                
                case let .success(value): _result.author = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["title"] as AnyObject?) {
                
                case let .success(value): _result.title = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["url"] as AnyObject?) {
                
                case let .success(value): _result.url = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PipelineBranchesitempullRequest", actual: "\(source)"))
            }
        }
        // Decoder for [PipelineBranchesitempullRequestlinks]
        Decoders.addDecoder(clazz: [PipelineBranchesitempullRequestlinks].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PipelineBranchesitempullRequestlinks]> in
            return Decoders.decode(clazz: [PipelineBranchesitempullRequestlinks].self, source: source)
        }

        // Decoder for PipelineBranchesitempullRequestlinks
        Decoders.addDecoder(clazz: PipelineBranchesitempullRequestlinks.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PipelineBranchesitempullRequestlinks> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PipelineBranchesitempullRequestlinks() : instance as! PipelineBranchesitempullRequestlinks
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["self"] as AnyObject?) {
                
                case let .success(value): _result._self = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PipelineBranchesitempullRequestlinks", actual: "\(source)"))
            }
        }
        // Decoder for [PipelineFolderImpl]
        Decoders.addDecoder(clazz: [PipelineFolderImpl].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PipelineFolderImpl]> in
            return Decoders.decode(clazz: [PipelineFolderImpl].self, source: source)
        }

        // Decoder for PipelineFolderImpl
        Decoders.addDecoder(clazz: PipelineFolderImpl.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PipelineFolderImpl> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PipelineFolderImpl() : instance as! PipelineFolderImpl
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["displayName"] as AnyObject?) {
                
                case let .success(value): _result.displayName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fullName"] as AnyObject?) {
                
                case let .success(value): _result.fullName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["organization"] as AnyObject?) {
                
                case let .success(value): _result.organization = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["numberOfFolders"] as AnyObject?) {
                
                case let .success(value): _result.numberOfFolders = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["numberOfPipelines"] as AnyObject?) {
                
                case let .success(value): _result.numberOfPipelines = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PipelineFolderImpl", actual: "\(source)"))
            }
        }
        // Decoder for [PipelineImpl]
        Decoders.addDecoder(clazz: [PipelineImpl].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PipelineImpl]> in
            return Decoders.decode(clazz: [PipelineImpl].self, source: source)
        }

        // Decoder for PipelineImpl
        Decoders.addDecoder(clazz: PipelineImpl.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PipelineImpl> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PipelineImpl() : instance as! PipelineImpl
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["displayName"] as AnyObject?) {
                
                case let .success(value): _result.displayName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["estimatedDurationInMillis"] as AnyObject?) {
                
                case let .success(value): _result.estimatedDurationInMillis = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fullName"] as AnyObject?) {
                
                case let .success(value): _result.fullName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latestRun"] as AnyObject?) {
                
                case let .success(value): _result.latestRun = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["organization"] as AnyObject?) {
                
                case let .success(value): _result.organization = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["weatherScore"] as AnyObject?) {
                
                case let .success(value): _result.weatherScore = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: PipelineImpllinks.self, source: sourceDictionary["_links"] as AnyObject?) {
                
                case let .success(value): _result.links = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PipelineImpl", actual: "\(source)"))
            }
        }
        // Decoder for [PipelineImpllinks]
        Decoders.addDecoder(clazz: [PipelineImpllinks].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PipelineImpllinks]> in
            return Decoders.decode(clazz: [PipelineImpllinks].self, source: source)
        }

        // Decoder for PipelineImpllinks
        Decoders.addDecoder(clazz: PipelineImpllinks.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PipelineImpllinks> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PipelineImpllinks() : instance as! PipelineImpllinks
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["runs"] as AnyObject?) {
                
                case let .success(value): _result.runs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["self"] as AnyObject?) {
                
                case let .success(value): _result._self = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["queue"] as AnyObject?) {
                
                case let .success(value): _result.queue = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["actions"] as AnyObject?) {
                
                case let .success(value): _result.actions = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PipelineImpllinks", actual: "\(source)"))
            }
        }
        // Decoder for [PipelineRun]
        Decoders.addDecoder(clazz: [PipelineRun].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PipelineRun]> in
            return Decoders.decode(clazz: [PipelineRun].self, source: source)
        }

        // Decoder for PipelineRun
        Decoders.addDecoder(clazz: PipelineRun.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PipelineRun> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PipelineRun() : instance as! PipelineRun
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [PipelineRunartifacts].self, source: sourceDictionary["artifacts"] as AnyObject?) {
                
                case let .success(value): _result.artifacts = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["durationInMillis"] as AnyObject?) {
                
                case let .success(value): _result.durationInMillis = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["estimatedDurationInMillis"] as AnyObject?) {
                
                case let .success(value): _result.estimatedDurationInMillis = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["enQueueTime"] as AnyObject?) {
                
                case let .success(value): _result.enQueueTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["endTime"] as AnyObject?) {
                
                case let .success(value): _result.endTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["organization"] as AnyObject?) {
                
                case let .success(value): _result.organization = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["pipeline"] as AnyObject?) {
                
                case let .success(value): _result.pipeline = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["result"] as AnyObject?) {
                
                case let .success(value): _result.result = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["runSummary"] as AnyObject?) {
                
                case let .success(value): _result.runSummary = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["startTime"] as AnyObject?) {
                
                case let .success(value): _result.startTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["state"] as AnyObject?) {
                
                case let .success(value): _result.state = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["commitId"] as AnyObject?) {
                
                case let .success(value): _result.commitId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PipelineRun", actual: "\(source)"))
            }
        }
        // Decoder for [PipelineRunImpl]
        Decoders.addDecoder(clazz: [PipelineRunImpl].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PipelineRunImpl]> in
            return Decoders.decode(clazz: [PipelineRunImpl].self, source: source)
        }

        // Decoder for PipelineRunImpl
        Decoders.addDecoder(clazz: PipelineRunImpl.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PipelineRunImpl> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PipelineRunImpl() : instance as! PipelineRunImpl
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: PipelineRunImpllinks.self, source: sourceDictionary["_links"] as AnyObject?) {
                
                case let .success(value): _result.links = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["durationInMillis"] as AnyObject?) {
                
                case let .success(value): _result.durationInMillis = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["enQueueTime"] as AnyObject?) {
                
                case let .success(value): _result.enQueueTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["endTime"] as AnyObject?) {
                
                case let .success(value): _result.endTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["estimatedDurationInMillis"] as AnyObject?) {
                
                case let .success(value): _result.estimatedDurationInMillis = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["organization"] as AnyObject?) {
                
                case let .success(value): _result.organization = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["pipeline"] as AnyObject?) {
                
                case let .success(value): _result.pipeline = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["result"] as AnyObject?) {
                
                case let .success(value): _result.result = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["runSummary"] as AnyObject?) {
                
                case let .success(value): _result.runSummary = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["startTime"] as AnyObject?) {
                
                case let .success(value): _result.startTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["state"] as AnyObject?) {
                
                case let .success(value): _result.state = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["commitId"] as AnyObject?) {
                
                case let .success(value): _result.commitId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PipelineRunImpl", actual: "\(source)"))
            }
        }
        // Decoder for [PipelineRunImpllinks]
        Decoders.addDecoder(clazz: [PipelineRunImpllinks].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PipelineRunImpllinks]> in
            return Decoders.decode(clazz: [PipelineRunImpllinks].self, source: source)
        }

        // Decoder for PipelineRunImpllinks
        Decoders.addDecoder(clazz: PipelineRunImpllinks.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PipelineRunImpllinks> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PipelineRunImpllinks() : instance as! PipelineRunImpllinks
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["nodes"] as AnyObject?) {
                
                case let .success(value): _result.nodes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["log"] as AnyObject?) {
                
                case let .success(value): _result.log = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["self"] as AnyObject?) {
                
                case let .success(value): _result._self = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["actions"] as AnyObject?) {
                
                case let .success(value): _result.actions = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["steps"] as AnyObject?) {
                
                case let .success(value): _result.steps = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PipelineRunImpllinks", actual: "\(source)"))
            }
        }
        // Decoder for [PipelineRunNode]
        Decoders.addDecoder(clazz: [PipelineRunNode].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PipelineRunNode]> in
            return Decoders.decode(clazz: [PipelineRunNode].self, source: source)
        }

        // Decoder for PipelineRunNode
        Decoders.addDecoder(clazz: PipelineRunNode.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PipelineRunNode> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PipelineRunNode() : instance as! PipelineRunNode
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["displayName"] as AnyObject?) {
                
                case let .success(value): _result.displayName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["durationInMillis"] as AnyObject?) {
                
                case let .success(value): _result.durationInMillis = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [PipelineRunNodeedges].self, source: sourceDictionary["edges"] as AnyObject?) {
                
                case let .success(value): _result.edges = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["result"] as AnyObject?) {
                
                case let .success(value): _result.result = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["startTime"] as AnyObject?) {
                
                case let .success(value): _result.startTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["state"] as AnyObject?) {
                
                case let .success(value): _result.state = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PipelineRunNode", actual: "\(source)"))
            }
        }
        // Decoder for [PipelineRunNodeedges]
        Decoders.addDecoder(clazz: [PipelineRunNodeedges].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PipelineRunNodeedges]> in
            return Decoders.decode(clazz: [PipelineRunNodeedges].self, source: source)
        }

        // Decoder for PipelineRunNodeedges
        Decoders.addDecoder(clazz: PipelineRunNodeedges.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PipelineRunNodeedges> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PipelineRunNodeedges() : instance as! PipelineRunNodeedges
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PipelineRunNodeedges", actual: "\(source)"))
            }
        }
        // Decoder for [PipelineRunartifacts]
        Decoders.addDecoder(clazz: [PipelineRunartifacts].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PipelineRunartifacts]> in
            return Decoders.decode(clazz: [PipelineRunartifacts].self, source: source)
        }

        // Decoder for PipelineRunartifacts
        Decoders.addDecoder(clazz: PipelineRunartifacts.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PipelineRunartifacts> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PipelineRunartifacts() : instance as! PipelineRunartifacts
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): _result.size = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["url"] as AnyObject?) {
                
                case let .success(value): _result.url = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PipelineRunartifacts", actual: "\(source)"))
            }
        }
        // Decoder for [PipelineStepImpl]
        Decoders.addDecoder(clazz: [PipelineStepImpl].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PipelineStepImpl]> in
            return Decoders.decode(clazz: [PipelineStepImpl].self, source: source)
        }

        // Decoder for PipelineStepImpl
        Decoders.addDecoder(clazz: PipelineStepImpl.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PipelineStepImpl> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PipelineStepImpl() : instance as! PipelineStepImpl
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: PipelineStepImpllinks.self, source: sourceDictionary["_links"] as AnyObject?) {
                
                case let .success(value): _result.links = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["displayName"] as AnyObject?) {
                
                case let .success(value): _result.displayName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["durationInMillis"] as AnyObject?) {
                
                case let .success(value): _result.durationInMillis = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: InputStepImpl.self, source: sourceDictionary["input"] as AnyObject?) {
                
                case let .success(value): _result.input = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["result"] as AnyObject?) {
                
                case let .success(value): _result.result = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["startTime"] as AnyObject?) {
                
                case let .success(value): _result.startTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["state"] as AnyObject?) {
                
                case let .success(value): _result.state = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PipelineStepImpl", actual: "\(source)"))
            }
        }
        // Decoder for [PipelineStepImpllinks]
        Decoders.addDecoder(clazz: [PipelineStepImpllinks].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PipelineStepImpllinks]> in
            return Decoders.decode(clazz: [PipelineStepImpllinks].self, source: source)
        }

        // Decoder for PipelineStepImpllinks
        Decoders.addDecoder(clazz: PipelineStepImpllinks.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PipelineStepImpllinks> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PipelineStepImpllinks() : instance as! PipelineStepImpllinks
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["self"] as AnyObject?) {
                
                case let .success(value): _result._self = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Link.self, source: sourceDictionary["actions"] as AnyObject?) {
                
                case let .success(value): _result.actions = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PipelineStepImpllinks", actual: "\(source)"))
            }
        }
        // Decoder for [PipelinelatestRun]
        Decoders.addDecoder(clazz: [PipelinelatestRun].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PipelinelatestRun]> in
            return Decoders.decode(clazz: [PipelinelatestRun].self, source: source)
        }

        // Decoder for PipelinelatestRun
        Decoders.addDecoder(clazz: PipelinelatestRun.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PipelinelatestRun> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PipelinelatestRun() : instance as! PipelinelatestRun
                switch Decoders.decodeOptional(clazz: [PipelinelatestRunartifacts].self, source: sourceDictionary["artifacts"] as AnyObject?) {
                
                case let .success(value): _result.artifacts = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["durationInMillis"] as AnyObject?) {
                
                case let .success(value): _result.durationInMillis = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["estimatedDurationInMillis"] as AnyObject?) {
                
                case let .success(value): _result.estimatedDurationInMillis = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["enQueueTime"] as AnyObject?) {
                
                case let .success(value): _result.enQueueTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["endTime"] as AnyObject?) {
                
                case let .success(value): _result.endTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["organization"] as AnyObject?) {
                
                case let .success(value): _result.organization = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["pipeline"] as AnyObject?) {
                
                case let .success(value): _result.pipeline = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["result"] as AnyObject?) {
                
                case let .success(value): _result.result = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["runSummary"] as AnyObject?) {
                
                case let .success(value): _result.runSummary = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["startTime"] as AnyObject?) {
                
                case let .success(value): _result.startTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["state"] as AnyObject?) {
                
                case let .success(value): _result.state = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["commitId"] as AnyObject?) {
                
                case let .success(value): _result.commitId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PipelinelatestRun", actual: "\(source)"))
            }
        }
        // Decoder for [PipelinelatestRunartifacts]
        Decoders.addDecoder(clazz: [PipelinelatestRunartifacts].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PipelinelatestRunartifacts]> in
            return Decoders.decode(clazz: [PipelinelatestRunartifacts].self, source: source)
        }

        // Decoder for PipelinelatestRunartifacts
        Decoders.addDecoder(clazz: PipelinelatestRunartifacts.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PipelinelatestRunartifacts> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PipelinelatestRunartifacts() : instance as! PipelinelatestRunartifacts
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): _result.size = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["url"] as AnyObject?) {
                
                case let .success(value): _result.url = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PipelinelatestRunartifacts", actual: "\(source)"))
            }
        }
        // Decoder for [Queue]
        Decoders.addDecoder(clazz: [Queue].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Queue]> in
            return Decoders.decode(clazz: [Queue].self, source: source)
        }

        // Decoder for Queue
        Decoders.addDecoder(clazz: Queue.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Queue> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Queue() : instance as! Queue
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [QueueBlockedItem].self, source: sourceDictionary["items"] as AnyObject?) {
                
                case let .success(value): _result.items = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Queue", actual: "\(source)"))
            }
        }
        // Decoder for [QueueBlockedItem]
        Decoders.addDecoder(clazz: [QueueBlockedItem].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[QueueBlockedItem]> in
            return Decoders.decode(clazz: [QueueBlockedItem].self, source: source)
        }

        // Decoder for QueueBlockedItem
        Decoders.addDecoder(clazz: QueueBlockedItem.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<QueueBlockedItem> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? QueueBlockedItem() : instance as! QueueBlockedItem
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [CauseAction].self, source: sourceDictionary["actions"] as AnyObject?) {
                
                case let .success(value): _result.actions = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["blocked"] as AnyObject?) {
                
                case let .success(value): _result.blocked = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["buildable"] as AnyObject?) {
                
                case let .success(value): _result.buildable = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["inQueueSince"] as AnyObject?) {
                
                case let .success(value): _result.inQueueSince = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["params"] as AnyObject?) {
                
                case let .success(value): _result.params = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["stuck"] as AnyObject?) {
                
                case let .success(value): _result.stuck = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: FreeStyleProject.self, source: sourceDictionary["task"] as AnyObject?) {
                
                case let .success(value): _result.task = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["url"] as AnyObject?) {
                
                case let .success(value): _result.url = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["why"] as AnyObject?) {
                
                case let .success(value): _result.why = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["buildableStartMilliseconds"] as AnyObject?) {
                
                case let .success(value): _result.buildableStartMilliseconds = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "QueueBlockedItem", actual: "\(source)"))
            }
        }
        // Decoder for [QueueItemImpl]
        Decoders.addDecoder(clazz: [QueueItemImpl].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[QueueItemImpl]> in
            return Decoders.decode(clazz: [QueueItemImpl].self, source: source)
        }

        // Decoder for QueueItemImpl
        Decoders.addDecoder(clazz: QueueItemImpl.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<QueueItemImpl> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? QueueItemImpl() : instance as! QueueItemImpl
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["expectedBuildNumber"] as AnyObject?) {
                
                case let .success(value): _result.expectedBuildNumber = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["pipeline"] as AnyObject?) {
                
                case let .success(value): _result.pipeline = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["queuedTime"] as AnyObject?) {
                
                case let .success(value): _result.queuedTime = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "QueueItemImpl", actual: "\(source)"))
            }
        }
        // Decoder for [QueueLeftItem]
        Decoders.addDecoder(clazz: [QueueLeftItem].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[QueueLeftItem]> in
            return Decoders.decode(clazz: [QueueLeftItem].self, source: source)
        }

        // Decoder for QueueLeftItem
        Decoders.addDecoder(clazz: QueueLeftItem.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<QueueLeftItem> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? QueueLeftItem() : instance as! QueueLeftItem
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [CauseAction].self, source: sourceDictionary["actions"] as AnyObject?) {
                
                case let .success(value): _result.actions = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["blocked"] as AnyObject?) {
                
                case let .success(value): _result.blocked = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["buildable"] as AnyObject?) {
                
                case let .success(value): _result.buildable = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["inQueueSince"] as AnyObject?) {
                
                case let .success(value): _result.inQueueSince = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["params"] as AnyObject?) {
                
                case let .success(value): _result.params = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["stuck"] as AnyObject?) {
                
                case let .success(value): _result.stuck = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: FreeStyleProject.self, source: sourceDictionary["task"] as AnyObject?) {
                
                case let .success(value): _result.task = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["url"] as AnyObject?) {
                
                case let .success(value): _result.url = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["why"] as AnyObject?) {
                
                case let .success(value): _result.why = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["cancelled"] as AnyObject?) {
                
                case let .success(value): _result.cancelled = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: FreeStyleBuild.self, source: sourceDictionary["executable"] as AnyObject?) {
                
                case let .success(value): _result.executable = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "QueueLeftItem", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeMonitorData]
        Decoders.addDecoder(clazz: [ResponseTimeMonitorData].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeMonitorData]> in
            return Decoders.decode(clazz: [ResponseTimeMonitorData].self, source: source)
        }

        // Decoder for ResponseTimeMonitorData
        Decoders.addDecoder(clazz: ResponseTimeMonitorData.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeMonitorData> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeMonitorData() : instance as! ResponseTimeMonitorData
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["timestamp"] as AnyObject?) {
                
                case let .success(value): _result.timestamp = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["average"] as AnyObject?) {
                
                case let .success(value): _result.average = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeMonitorData", actual: "\(source)"))
            }
        }
        // Decoder for [StringParameterDefinition]
        Decoders.addDecoder(clazz: [StringParameterDefinition].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[StringParameterDefinition]> in
            return Decoders.decode(clazz: [StringParameterDefinition].self, source: source)
        }

        // Decoder for StringParameterDefinition
        Decoders.addDecoder(clazz: StringParameterDefinition.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<StringParameterDefinition> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? StringParameterDefinition() : instance as! StringParameterDefinition
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: StringParameterValue.self, source: sourceDictionary["defaultParameterValue"] as AnyObject?) {
                
                case let .success(value): _result.defaultParameterValue = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): _result.description = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "StringParameterDefinition", actual: "\(source)"))
            }
        }
        // Decoder for [StringParameterValue]
        Decoders.addDecoder(clazz: [StringParameterValue].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[StringParameterValue]> in
            return Decoders.decode(clazz: [StringParameterValue].self, source: source)
        }

        // Decoder for StringParameterValue
        Decoders.addDecoder(clazz: StringParameterValue.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<StringParameterValue> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? StringParameterValue() : instance as! StringParameterValue
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): _result.value = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "StringParameterValue", actual: "\(source)"))
            }
        }
        // Decoder for [SwapSpaceMonitorMemoryUsage2]
        Decoders.addDecoder(clazz: [SwapSpaceMonitorMemoryUsage2].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[SwapSpaceMonitorMemoryUsage2]> in
            return Decoders.decode(clazz: [SwapSpaceMonitorMemoryUsage2].self, source: source)
        }

        // Decoder for SwapSpaceMonitorMemoryUsage2
        Decoders.addDecoder(clazz: SwapSpaceMonitorMemoryUsage2.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SwapSpaceMonitorMemoryUsage2> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? SwapSpaceMonitorMemoryUsage2() : instance as! SwapSpaceMonitorMemoryUsage2
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["availablePhysicalMemory"] as AnyObject?) {
                
                case let .success(value): _result.availablePhysicalMemory = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["availableSwapSpace"] as AnyObject?) {
                
                case let .success(value): _result.availableSwapSpace = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalPhysicalMemory"] as AnyObject?) {
                
                case let .success(value): _result.totalPhysicalMemory = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalSwapSpace"] as AnyObject?) {
                
                case let .success(value): _result.totalSwapSpace = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "SwapSpaceMonitorMemoryUsage2", actual: "\(source)"))
            }
        }
        // Decoder for [UnlabeledLoadStatistics]
        Decoders.addDecoder(clazz: [UnlabeledLoadStatistics].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UnlabeledLoadStatistics]> in
            return Decoders.decode(clazz: [UnlabeledLoadStatistics].self, source: source)
        }

        // Decoder for UnlabeledLoadStatistics
        Decoders.addDecoder(clazz: UnlabeledLoadStatistics.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UnlabeledLoadStatistics> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? UnlabeledLoadStatistics() : instance as! UnlabeledLoadStatistics
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UnlabeledLoadStatistics", actual: "\(source)"))
            }
        }
        // Decoder for [User]
        Decoders.addDecoder(clazz: [User].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[User]> in
            return Decoders.decode(clazz: [User].self, source: source)
        }

        // Decoder for User
        Decoders.addDecoder(clazz: User.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<User> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? User() : instance as! User
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                
                case let .success(value): _result._class = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fullName"] as AnyObject?) {
                
                case let .success(value): _result.fullName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?) {
                
                case let .success(value): _result.email = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "User", actual: "\(source)"))
            }
        }
    }()

    static fileprivate func initialize() {
        _ = Decoders.__once
    }
}
