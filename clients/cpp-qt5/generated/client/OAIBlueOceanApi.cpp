/**
 * Swaggy Jenkins
 * Jenkins API clients generated from Swagger / Open API specification
 *
 * OpenAPI spec version: 1.1.1
 * Contact: blah@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIBlueOceanApi.h"
#include "OAIHelpers.h"
#include "OAIModelFactory.h"
#include "OAIQObjectWrapper.h"

#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIBlueOceanApi::OAIBlueOceanApi() {}

OAIBlueOceanApi::~OAIBlueOceanApi() {}

OAIBlueOceanApi::OAIBlueOceanApi(QString host, QString basePath) {
    this->host = host;
    this->basePath = basePath;
}

void
OAIBlueOceanApi::deletePipelineQueueItem(QString* organization, QString* pipeline, QString* queue) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue/{queue}");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString pipelinePathParam("{"); pipelinePathParam.append("pipeline").append("}");
    fullPath.replace(pipelinePathParam, stringValue(pipeline));
    QString queuePathParam("{"); queuePathParam.append("queue").append("}");
    fullPath.replace(queuePathParam, stringValue(queue));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "DELETE");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::deletePipelineQueueItemCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::deletePipelineQueueItemCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit deletePipelineQueueItemSignal();
    } else {
        emit deletePipelineQueueItemSignalE(error_type, error_str);
        emit deletePipelineQueueItemSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getAuthenticatedUser(QString* organization) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/user/");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getAuthenticatedUserCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getAuthenticatedUserCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIUser* output = static_cast<OAIUser*>(create(json, QString("OAIUser")));
    auto wrapper = new OAIQObjectWrapper<OAIUser*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getAuthenticatedUserSignal(output);
    } else {
        emit getAuthenticatedUserSignalE(output, error_type, error_str);
        emit getAuthenticatedUserSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getClasses(QString* _class) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/classes/{class}");

    QString _classPathParam("{"); _classPathParam.append("class").append("}");
    fullPath.replace(_classPathParam, stringValue(_class));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getClassesCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getClassesCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    QString* output = static_cast<QString*>(create(json, QString("QString")));
    auto wrapper = new OAIQObjectWrapper<QString*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getClassesSignal(output);
    } else {
        emit getClassesSignalE(output, error_type, error_str);
        emit getClassesSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getJsonWebKey(qint32 key) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/jwt-auth/jwks/{key}");

    QString keyPathParam("{"); keyPathParam.append("key").append("}");
    fullPath.replace(keyPathParam, stringValue(key));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getJsonWebKeyCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getJsonWebKeyCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    QString* output = static_cast<QString*>(create(json, QString("QString")));
    auto wrapper = new OAIQObjectWrapper<QString*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getJsonWebKeySignal(output);
    } else {
        emit getJsonWebKeySignalE(output, error_type, error_str);
        emit getJsonWebKeySignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getJsonWebToken(qint32 expiry_time_in_mins, qint32 max_expiry_time_in_mins) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/jwt-auth/token");


    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("expiryTimeInMins"))
        .append("=")
        .append(QUrl::toPercentEncoding(stringValue(expiry_time_in_mins)));

    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("maxExpiryTimeInMins"))
        .append("=")
        .append(QUrl::toPercentEncoding(stringValue(max_expiry_time_in_mins)));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getJsonWebTokenCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getJsonWebTokenCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    QString* output = static_cast<QString*>(create(json, QString("QString")));
    auto wrapper = new OAIQObjectWrapper<QString*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getJsonWebTokenSignal(output);
    } else {
        emit getJsonWebTokenSignalE(output, error_type, error_str);
        emit getJsonWebTokenSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getOrganisation(QString* organization) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getOrganisationCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getOrganisationCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIOrganisation* output = static_cast<OAIOrganisation*>(create(json, QString("OAIOrganisation")));
    auto wrapper = new OAIQObjectWrapper<OAIOrganisation*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getOrganisationSignal(output);
    } else {
        emit getOrganisationSignalE(output, error_type, error_str);
        emit getOrganisationSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getOrganisations() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/");



    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getOrganisationsCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getOrganisationsCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIOrganisations* output = static_cast<OAIOrganisations*>(create(json, QString("OAIOrganisations")));
    auto wrapper = new OAIQObjectWrapper<OAIOrganisations*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getOrganisationsSignal(output);
    } else {
        emit getOrganisationsSignalE(output, error_type, error_str);
        emit getOrganisationsSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getPipeline(QString* organization, QString* pipeline) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/pipelines/{pipeline}");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString pipelinePathParam("{"); pipelinePathParam.append("pipeline").append("}");
    fullPath.replace(pipelinePathParam, stringValue(pipeline));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getPipelineCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getPipelineCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIPipeline* output = static_cast<OAIPipeline*>(create(json, QString("OAIPipeline")));
    auto wrapper = new OAIQObjectWrapper<OAIPipeline*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPipelineSignal(output);
    } else {
        emit getPipelineSignalE(output, error_type, error_str);
        emit getPipelineSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getPipelineActivities(QString* organization, QString* pipeline) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/pipelines/{pipeline}/activities");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString pipelinePathParam("{"); pipelinePathParam.append("pipeline").append("}");
    fullPath.replace(pipelinePathParam, stringValue(pipeline));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getPipelineActivitiesCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getPipelineActivitiesCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIPipelineActivities* output = static_cast<OAIPipelineActivities*>(create(json, QString("OAIPipelineActivities")));
    auto wrapper = new OAIQObjectWrapper<OAIPipelineActivities*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPipelineActivitiesSignal(output);
    } else {
        emit getPipelineActivitiesSignalE(output, error_type, error_str);
        emit getPipelineActivitiesSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getPipelineBranch(QString* organization, QString* pipeline, QString* branch) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString pipelinePathParam("{"); pipelinePathParam.append("pipeline").append("}");
    fullPath.replace(pipelinePathParam, stringValue(pipeline));
    QString branchPathParam("{"); branchPathParam.append("branch").append("}");
    fullPath.replace(branchPathParam, stringValue(branch));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getPipelineBranchCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getPipelineBranchCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIBranchImpl* output = static_cast<OAIBranchImpl*>(create(json, QString("OAIBranchImpl")));
    auto wrapper = new OAIQObjectWrapper<OAIBranchImpl*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPipelineBranchSignal(output);
    } else {
        emit getPipelineBranchSignalE(output, error_type, error_str);
        emit getPipelineBranchSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getPipelineBranchRun(QString* organization, QString* pipeline, QString* branch, QString* run) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/runs/{run}");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString pipelinePathParam("{"); pipelinePathParam.append("pipeline").append("}");
    fullPath.replace(pipelinePathParam, stringValue(pipeline));
    QString branchPathParam("{"); branchPathParam.append("branch").append("}");
    fullPath.replace(branchPathParam, stringValue(branch));
    QString runPathParam("{"); runPathParam.append("run").append("}");
    fullPath.replace(runPathParam, stringValue(run));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getPipelineBranchRunCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getPipelineBranchRunCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIPipelineRun* output = static_cast<OAIPipelineRun*>(create(json, QString("OAIPipelineRun")));
    auto wrapper = new OAIQObjectWrapper<OAIPipelineRun*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPipelineBranchRunSignal(output);
    } else {
        emit getPipelineBranchRunSignalE(output, error_type, error_str);
        emit getPipelineBranchRunSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getPipelineBranches(QString* organization, QString* pipeline) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString pipelinePathParam("{"); pipelinePathParam.append("pipeline").append("}");
    fullPath.replace(pipelinePathParam, stringValue(pipeline));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getPipelineBranchesCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getPipelineBranchesCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIMultibranchPipeline* output = static_cast<OAIMultibranchPipeline*>(create(json, QString("OAIMultibranchPipeline")));
    auto wrapper = new OAIQObjectWrapper<OAIMultibranchPipeline*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPipelineBranchesSignal(output);
    } else {
        emit getPipelineBranchesSignalE(output, error_type, error_str);
        emit getPipelineBranchesSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getPipelineFolder(QString* organization, QString* folder) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/pipelines/{folder}/");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString folderPathParam("{"); folderPathParam.append("folder").append("}");
    fullPath.replace(folderPathParam, stringValue(folder));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getPipelineFolderCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getPipelineFolderCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIPipelineFolderImpl* output = static_cast<OAIPipelineFolderImpl*>(create(json, QString("OAIPipelineFolderImpl")));
    auto wrapper = new OAIQObjectWrapper<OAIPipelineFolderImpl*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPipelineFolderSignal(output);
    } else {
        emit getPipelineFolderSignalE(output, error_type, error_str);
        emit getPipelineFolderSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getPipelineFolderPipeline(QString* organization, QString* pipeline, QString* folder) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/pipelines/{folder}/pipelines/{pipeline}");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString pipelinePathParam("{"); pipelinePathParam.append("pipeline").append("}");
    fullPath.replace(pipelinePathParam, stringValue(pipeline));
    QString folderPathParam("{"); folderPathParam.append("folder").append("}");
    fullPath.replace(folderPathParam, stringValue(folder));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getPipelineFolderPipelineCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getPipelineFolderPipelineCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIPipelineImpl* output = static_cast<OAIPipelineImpl*>(create(json, QString("OAIPipelineImpl")));
    auto wrapper = new OAIQObjectWrapper<OAIPipelineImpl*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPipelineFolderPipelineSignal(output);
    } else {
        emit getPipelineFolderPipelineSignalE(output, error_type, error_str);
        emit getPipelineFolderPipelineSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getPipelineQueue(QString* organization, QString* pipeline) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString pipelinePathParam("{"); pipelinePathParam.append("pipeline").append("}");
    fullPath.replace(pipelinePathParam, stringValue(pipeline));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getPipelineQueueCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getPipelineQueueCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIPipelineQueue* output = static_cast<OAIPipelineQueue*>(create(json, QString("OAIPipelineQueue")));
    auto wrapper = new OAIQObjectWrapper<OAIPipelineQueue*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPipelineQueueSignal(output);
    } else {
        emit getPipelineQueueSignalE(output, error_type, error_str);
        emit getPipelineQueueSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getPipelineRun(QString* organization, QString* pipeline, QString* run) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString pipelinePathParam("{"); pipelinePathParam.append("pipeline").append("}");
    fullPath.replace(pipelinePathParam, stringValue(pipeline));
    QString runPathParam("{"); runPathParam.append("run").append("}");
    fullPath.replace(runPathParam, stringValue(run));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getPipelineRunCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getPipelineRunCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIPipelineRun* output = static_cast<OAIPipelineRun*>(create(json, QString("OAIPipelineRun")));
    auto wrapper = new OAIQObjectWrapper<OAIPipelineRun*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPipelineRunSignal(output);
    } else {
        emit getPipelineRunSignalE(output, error_type, error_str);
        emit getPipelineRunSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getPipelineRunLog(QString* organization, QString* pipeline, QString* run, qint32 start, bool download) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/log");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString pipelinePathParam("{"); pipelinePathParam.append("pipeline").append("}");
    fullPath.replace(pipelinePathParam, stringValue(pipeline));
    QString runPathParam("{"); runPathParam.append("run").append("}");
    fullPath.replace(runPathParam, stringValue(run));

    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("start"))
        .append("=")
        .append(QUrl::toPercentEncoding(stringValue(start)));

    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("download"))
        .append("=")
        .append(QUrl::toPercentEncoding(stringValue(download)));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getPipelineRunLogCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getPipelineRunLogCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    QString* output = static_cast<QString*>(create(json, QString("QString")));
    auto wrapper = new OAIQObjectWrapper<QString*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPipelineRunLogSignal(output);
    } else {
        emit getPipelineRunLogSignalE(output, error_type, error_str);
        emit getPipelineRunLogSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getPipelineRunNode(QString* organization, QString* pipeline, QString* run, QString* node) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString pipelinePathParam("{"); pipelinePathParam.append("pipeline").append("}");
    fullPath.replace(pipelinePathParam, stringValue(pipeline));
    QString runPathParam("{"); runPathParam.append("run").append("}");
    fullPath.replace(runPathParam, stringValue(run));
    QString nodePathParam("{"); nodePathParam.append("node").append("}");
    fullPath.replace(nodePathParam, stringValue(node));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getPipelineRunNodeCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getPipelineRunNodeCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIPipelineRunNode* output = static_cast<OAIPipelineRunNode*>(create(json, QString("OAIPipelineRunNode")));
    auto wrapper = new OAIQObjectWrapper<OAIPipelineRunNode*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPipelineRunNodeSignal(output);
    } else {
        emit getPipelineRunNodeSignalE(output, error_type, error_str);
        emit getPipelineRunNodeSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getPipelineRunNodeStep(QString* organization, QString* pipeline, QString* run, QString* node, QString* step) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString pipelinePathParam("{"); pipelinePathParam.append("pipeline").append("}");
    fullPath.replace(pipelinePathParam, stringValue(pipeline));
    QString runPathParam("{"); runPathParam.append("run").append("}");
    fullPath.replace(runPathParam, stringValue(run));
    QString nodePathParam("{"); nodePathParam.append("node").append("}");
    fullPath.replace(nodePathParam, stringValue(node));
    QString stepPathParam("{"); stepPathParam.append("step").append("}");
    fullPath.replace(stepPathParam, stringValue(step));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getPipelineRunNodeStepCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getPipelineRunNodeStepCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIPipelineStepImpl* output = static_cast<OAIPipelineStepImpl*>(create(json, QString("OAIPipelineStepImpl")));
    auto wrapper = new OAIQObjectWrapper<OAIPipelineStepImpl*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPipelineRunNodeStepSignal(output);
    } else {
        emit getPipelineRunNodeStepSignalE(output, error_type, error_str);
        emit getPipelineRunNodeStepSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getPipelineRunNodeStepLog(QString* organization, QString* pipeline, QString* run, QString* node, QString* step) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}/log");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString pipelinePathParam("{"); pipelinePathParam.append("pipeline").append("}");
    fullPath.replace(pipelinePathParam, stringValue(pipeline));
    QString runPathParam("{"); runPathParam.append("run").append("}");
    fullPath.replace(runPathParam, stringValue(run));
    QString nodePathParam("{"); nodePathParam.append("node").append("}");
    fullPath.replace(nodePathParam, stringValue(node));
    QString stepPathParam("{"); stepPathParam.append("step").append("}");
    fullPath.replace(stepPathParam, stringValue(step));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getPipelineRunNodeStepLogCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getPipelineRunNodeStepLogCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    QString* output = static_cast<QString*>(create(json, QString("QString")));
    auto wrapper = new OAIQObjectWrapper<QString*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPipelineRunNodeStepLogSignal(output);
    } else {
        emit getPipelineRunNodeStepLogSignalE(output, error_type, error_str);
        emit getPipelineRunNodeStepLogSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getPipelineRunNodeSteps(QString* organization, QString* pipeline, QString* run, QString* node) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString pipelinePathParam("{"); pipelinePathParam.append("pipeline").append("}");
    fullPath.replace(pipelinePathParam, stringValue(pipeline));
    QString runPathParam("{"); runPathParam.append("run").append("}");
    fullPath.replace(runPathParam, stringValue(run));
    QString nodePathParam("{"); nodePathParam.append("node").append("}");
    fullPath.replace(nodePathParam, stringValue(node));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getPipelineRunNodeStepsCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getPipelineRunNodeStepsCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIPipelineRunNodeSteps* output = static_cast<OAIPipelineRunNodeSteps*>(create(json, QString("OAIPipelineRunNodeSteps")));
    auto wrapper = new OAIQObjectWrapper<OAIPipelineRunNodeSteps*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPipelineRunNodeStepsSignal(output);
    } else {
        emit getPipelineRunNodeStepsSignalE(output, error_type, error_str);
        emit getPipelineRunNodeStepsSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getPipelineRunNodes(QString* organization, QString* pipeline, QString* run) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString pipelinePathParam("{"); pipelinePathParam.append("pipeline").append("}");
    fullPath.replace(pipelinePathParam, stringValue(pipeline));
    QString runPathParam("{"); runPathParam.append("run").append("}");
    fullPath.replace(runPathParam, stringValue(run));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getPipelineRunNodesCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getPipelineRunNodesCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIPipelineRunNodes* output = static_cast<OAIPipelineRunNodes*>(create(json, QString("OAIPipelineRunNodes")));
    auto wrapper = new OAIQObjectWrapper<OAIPipelineRunNodes*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPipelineRunNodesSignal(output);
    } else {
        emit getPipelineRunNodesSignalE(output, error_type, error_str);
        emit getPipelineRunNodesSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getPipelineRuns(QString* organization, QString* pipeline) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString pipelinePathParam("{"); pipelinePathParam.append("pipeline").append("}");
    fullPath.replace(pipelinePathParam, stringValue(pipeline));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getPipelineRunsCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getPipelineRunsCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIPipelineRuns* output = static_cast<OAIPipelineRuns*>(create(json, QString("OAIPipelineRuns")));
    auto wrapper = new OAIQObjectWrapper<OAIPipelineRuns*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPipelineRunsSignal(output);
    } else {
        emit getPipelineRunsSignalE(output, error_type, error_str);
        emit getPipelineRunsSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getPipelines(QString* organization) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/pipelines/");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getPipelinesCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getPipelinesCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIPipelines* output = static_cast<OAIPipelines*>(create(json, QString("OAIPipelines")));
    auto wrapper = new OAIQObjectWrapper<OAIPipelines*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPipelinesSignal(output);
    } else {
        emit getPipelinesSignalE(output, error_type, error_str);
        emit getPipelinesSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getSCM(QString* organization, QString* scm) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/scm/{scm}");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString scmPathParam("{"); scmPathParam.append("scm").append("}");
    fullPath.replace(scmPathParam, stringValue(scm));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getSCMCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getSCMCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIGithubScm* output = static_cast<OAIGithubScm*>(create(json, QString("OAIGithubScm")));
    auto wrapper = new OAIQObjectWrapper<OAIGithubScm*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getSCMSignal(output);
    } else {
        emit getSCMSignalE(output, error_type, error_str);
        emit getSCMSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getSCMOrganisationRepositories(QString* organization, QString* scm, QString* scm_organisation, QString* credential_id, qint32 page_size, qint32 page_number) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString scmPathParam("{"); scmPathParam.append("scm").append("}");
    fullPath.replace(scmPathParam, stringValue(scm));
    QString scm_organisationPathParam("{"); scm_organisationPathParam.append("scmOrganisation").append("}");
    fullPath.replace(scm_organisationPathParam, stringValue(scm_organisation));

    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("credentialId"))
        .append("=")
        .append(QUrl::toPercentEncoding(stringValue(credential_id)));

    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("pageSize"))
        .append("=")
        .append(QUrl::toPercentEncoding(stringValue(page_size)));

    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("pageNumber"))
        .append("=")
        .append(QUrl::toPercentEncoding(stringValue(page_number)));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getSCMOrganisationRepositoriesCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getSCMOrganisationRepositoriesCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIScmOrganisations* output = static_cast<OAIScmOrganisations*>(create(json, QString("OAIScmOrganisations")));
    auto wrapper = new OAIQObjectWrapper<OAIScmOrganisations*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getSCMOrganisationRepositoriesSignal(output);
    } else {
        emit getSCMOrganisationRepositoriesSignalE(output, error_type, error_str);
        emit getSCMOrganisationRepositoriesSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getSCMOrganisationRepository(QString* organization, QString* scm, QString* scm_organisation, QString* repository, QString* credential_id) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories/{repository}");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString scmPathParam("{"); scmPathParam.append("scm").append("}");
    fullPath.replace(scmPathParam, stringValue(scm));
    QString scm_organisationPathParam("{"); scm_organisationPathParam.append("scmOrganisation").append("}");
    fullPath.replace(scm_organisationPathParam, stringValue(scm_organisation));
    QString repositoryPathParam("{"); repositoryPathParam.append("repository").append("}");
    fullPath.replace(repositoryPathParam, stringValue(repository));

    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("credentialId"))
        .append("=")
        .append(QUrl::toPercentEncoding(stringValue(credential_id)));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getSCMOrganisationRepositoryCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getSCMOrganisationRepositoryCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIScmOrganisations* output = static_cast<OAIScmOrganisations*>(create(json, QString("OAIScmOrganisations")));
    auto wrapper = new OAIQObjectWrapper<OAIScmOrganisations*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getSCMOrganisationRepositorySignal(output);
    } else {
        emit getSCMOrganisationRepositorySignalE(output, error_type, error_str);
        emit getSCMOrganisationRepositorySignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getSCMOrganisations(QString* organization, QString* scm, QString* credential_id) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/scm/{scm}/organizations");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString scmPathParam("{"); scmPathParam.append("scm").append("}");
    fullPath.replace(scmPathParam, stringValue(scm));

    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("credentialId"))
        .append("=")
        .append(QUrl::toPercentEncoding(stringValue(credential_id)));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getSCMOrganisationsCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getSCMOrganisationsCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIScmOrganisations* output = static_cast<OAIScmOrganisations*>(create(json, QString("OAIScmOrganisations")));
    auto wrapper = new OAIQObjectWrapper<OAIScmOrganisations*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getSCMOrganisationsSignal(output);
    } else {
        emit getSCMOrganisationsSignalE(output, error_type, error_str);
        emit getSCMOrganisationsSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getUser(QString* organization, QString* user) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/users/{user}");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString userPathParam("{"); userPathParam.append("user").append("}");
    fullPath.replace(userPathParam, stringValue(user));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getUserCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getUserCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIUser* output = static_cast<OAIUser*>(create(json, QString("OAIUser")));
    auto wrapper = new OAIQObjectWrapper<OAIUser*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getUserSignal(output);
    } else {
        emit getUserSignalE(output, error_type, error_str);
        emit getUserSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getUserFavorites(QString* user) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/users/{user}/favorites");

    QString userPathParam("{"); userPathParam.append("user").append("}");
    fullPath.replace(userPathParam, stringValue(user));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getUserFavoritesCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getUserFavoritesCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIUserFavorites* output = static_cast<OAIUserFavorites*>(create(json, QString("OAIUserFavorites")));
    auto wrapper = new OAIQObjectWrapper<OAIUserFavorites*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getUserFavoritesSignal(output);
    } else {
        emit getUserFavoritesSignalE(output, error_type, error_str);
        emit getUserFavoritesSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::getUsers(QString* organization) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/users/");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::getUsersCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::getUsersCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIUser* output = static_cast<OAIUser*>(create(json, QString("OAIUser")));
    auto wrapper = new OAIQObjectWrapper<OAIUser*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getUsersSignal(output);
    } else {
        emit getUsersSignalE(output, error_type, error_str);
        emit getUsersSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::postPipelineRun(QString* organization, QString* pipeline, QString* run) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/replay");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString pipelinePathParam("{"); pipelinePathParam.append("pipeline").append("}");
    fullPath.replace(pipelinePathParam, stringValue(pipeline));
    QString runPathParam("{"); runPathParam.append("run").append("}");
    fullPath.replace(runPathParam, stringValue(run));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "POST");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::postPipelineRunCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::postPipelineRunCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIQueueItemImpl* output = static_cast<OAIQueueItemImpl*>(create(json, QString("OAIQueueItemImpl")));
    auto wrapper = new OAIQObjectWrapper<OAIQueueItemImpl*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit postPipelineRunSignal(output);
    } else {
        emit postPipelineRunSignalE(output, error_type, error_str);
        emit postPipelineRunSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::postPipelineRuns(QString* organization, QString* pipeline) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString pipelinePathParam("{"); pipelinePathParam.append("pipeline").append("}");
    fullPath.replace(pipelinePathParam, stringValue(pipeline));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "POST");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::postPipelineRunsCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::postPipelineRunsCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIQueueItemImpl* output = static_cast<OAIQueueItemImpl*>(create(json, QString("OAIQueueItemImpl")));
    auto wrapper = new OAIQObjectWrapper<OAIQueueItemImpl*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit postPipelineRunsSignal(output);
    } else {
        emit postPipelineRunsSignalE(output, error_type, error_str);
        emit postPipelineRunsSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::putPipelineFavorite(QString* organization, QString* pipeline, OAIBody& oai_body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/pipelines/{pipeline}/favorite");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString pipelinePathParam("{"); pipelinePathParam.append("pipeline").append("}");
    fullPath.replace(pipelinePathParam, stringValue(pipeline));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "PUT");


    
    QString output = oai_body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::putPipelineFavoriteCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::putPipelineFavoriteCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIFavoriteImpl* output = static_cast<OAIFavoriteImpl*>(create(json, QString("OAIFavoriteImpl")));
    auto wrapper = new OAIQObjectWrapper<OAIFavoriteImpl*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit putPipelineFavoriteSignal(output);
    } else {
        emit putPipelineFavoriteSignalE(output, error_type, error_str);
        emit putPipelineFavoriteSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::putPipelineRun(QString* organization, QString* pipeline, QString* run, QString* blocking, qint32 time_out_in_secs) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/stop");

    QString organizationPathParam("{"); organizationPathParam.append("organization").append("}");
    fullPath.replace(organizationPathParam, stringValue(organization));
    QString pipelinePathParam("{"); pipelinePathParam.append("pipeline").append("}");
    fullPath.replace(pipelinePathParam, stringValue(pipeline));
    QString runPathParam("{"); runPathParam.append("run").append("}");
    fullPath.replace(runPathParam, stringValue(run));

    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("blocking"))
        .append("=")
        .append(QUrl::toPercentEncoding(stringValue(blocking)));

    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("timeOutInSecs"))
        .append("=")
        .append(QUrl::toPercentEncoding(stringValue(time_out_in_secs)));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "PUT");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::putPipelineRunCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::putPipelineRunCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    OAIPipelineRun* output = static_cast<OAIPipelineRun*>(create(json, QString("OAIPipelineRun")));
    auto wrapper = new OAIQObjectWrapper<OAIPipelineRun*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit putPipelineRunSignal(output);
    } else {
        emit putPipelineRunSignalE(output, error_type, error_str);
        emit putPipelineRunSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::search(QString* q) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/search/");


    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("q"))
        .append("=")
        .append(QUrl::toPercentEncoding(stringValue(q)));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::searchCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::searchCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    QString* output = static_cast<QString*>(create(json, QString("QString")));
    auto wrapper = new OAIQObjectWrapper<QString*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit searchSignal(output);
    } else {
        emit searchSignalE(output, error_type, error_str);
        emit searchSignalEFull(worker, error_type, error_str);
    }
}

void
OAIBlueOceanApi::searchClasses(QString* q) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/blue/rest/classes/");


    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("q"))
        .append("=")
        .append(QUrl::toPercentEncoding(stringValue(q)));


    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIBlueOceanApi::searchClassesCallback);

    worker->execute(&input);
}

void
OAIBlueOceanApi::searchClassesCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    QString* output = static_cast<QString*>(create(json, QString("QString")));
    auto wrapper = new OAIQObjectWrapper<QString*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit searchClassesSignal(output);
    } else {
        emit searchClassesSignalE(output, error_type, error_str);
        emit searchClassesSignalEFull(worker, error_type, error_str);
    }
}


}
