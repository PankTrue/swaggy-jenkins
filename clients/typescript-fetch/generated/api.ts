/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Swaggy Jenkins
 * Jenkins API clients generated from Swagger / Open API specification
 *
 * OpenAPI spec version: 1.1.0
 * Contact: blah@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AllView
 */
export interface AllView {
    /**
     * 
     * @type {string}
     * @memberof AllView
     */
    _class?: string;
    /**
     * 
     * @type {string}
     * @memberof AllView
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AllView
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface Body
 */
export interface Body {
    /**
     * 
     * @type {boolean}
     * @memberof Body
     */
    favorite: boolean;
}

/**
 * 
 * @export
 * @interface BranchImpl
 */
export interface BranchImpl {
    /**
     * 
     * @type {string}
     * @memberof BranchImpl
     */
    _class?: string;
    /**
     * 
     * @type {string}
     * @memberof BranchImpl
     */
    displayName?: string;
    /**
     * 
     * @type {number}
     * @memberof BranchImpl
     */
    estimatedDurationInMillis?: number;
    /**
     * 
     * @type {string}
     * @memberof BranchImpl
     */
    fullDisplayName?: string;
    /**
     * 
     * @type {string}
     * @memberof BranchImpl
     */
    fullName?: string;
    /**
     * 
     * @type {string}
     * @memberof BranchImpl
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof BranchImpl
     */
    organization?: string;
    /**
     * 
     * @type {Array<StringParameterDefinition>}
     * @memberof BranchImpl
     */
    parameters?: Array<StringParameterDefinition>;
    /**
     * 
     * @type {BranchImplpermissions}
     * @memberof BranchImpl
     */
    permissions?: BranchImplpermissions;
    /**
     * 
     * @type {number}
     * @memberof BranchImpl
     */
    weatherScore?: number;
    /**
     * 
     * @type {string}
     * @memberof BranchImpl
     */
    pullRequest?: string;
    /**
     * 
     * @type {BranchImpllinks}
     * @memberof BranchImpl
     */
    links?: BranchImpllinks;
    /**
     * 
     * @type {PipelineRunImpl}
     * @memberof BranchImpl
     */
    latestRun?: PipelineRunImpl;
}

/**
 * 
 * @export
 * @interface BranchImpllinks
 */
export interface BranchImpllinks {
    /**
     * 
     * @type {Link}
     * @memberof BranchImpllinks
     */
    self?: Link;
    /**
     * 
     * @type {Link}
     * @memberof BranchImpllinks
     */
    actions?: Link;
    /**
     * 
     * @type {Link}
     * @memberof BranchImpllinks
     */
    runs?: Link;
    /**
     * 
     * @type {Link}
     * @memberof BranchImpllinks
     */
    queue?: Link;
    /**
     * 
     * @type {string}
     * @memberof BranchImpllinks
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface BranchImplpermissions
 */
export interface BranchImplpermissions {
    /**
     * 
     * @type {boolean}
     * @memberof BranchImplpermissions
     */
    create?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BranchImplpermissions
     */
    read?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BranchImplpermissions
     */
    start?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BranchImplpermissions
     */
    stop?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BranchImplpermissions
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface CauseAction
 */
export interface CauseAction {
    /**
     * 
     * @type {string}
     * @memberof CauseAction
     */
    _class?: string;
    /**
     * 
     * @type {Array<CauseUserIdCause>}
     * @memberof CauseAction
     */
    causes?: Array<CauseUserIdCause>;
}

/**
 * 
 * @export
 * @interface CauseUserIdCause
 */
export interface CauseUserIdCause {
    /**
     * 
     * @type {string}
     * @memberof CauseUserIdCause
     */
    _class?: string;
    /**
     * 
     * @type {string}
     * @memberof CauseUserIdCause
     */
    shortDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof CauseUserIdCause
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof CauseUserIdCause
     */
    userName?: string;
}

/**
 * 
 * @export
 * @interface ClassesByClass
 */
export interface ClassesByClass {
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassesByClass
     */
    classes?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClassesByClass
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface ClockDifference
 */
export interface ClockDifference {
    /**
     * 
     * @type {string}
     * @memberof ClockDifference
     */
    _class?: string;
    /**
     * 
     * @type {number}
     * @memberof ClockDifference
     */
    diff?: number;
}

/**
 * 
 * @export
 * @interface ComputerSet
 */
export interface ComputerSet {
    /**
     * 
     * @type {string}
     * @memberof ComputerSet
     */
    _class?: string;
    /**
     * 
     * @type {number}
     * @memberof ComputerSet
     */
    busyExecutors?: number;
    /**
     * 
     * @type {Array<HudsonMasterComputer>}
     * @memberof ComputerSet
     */
    computer?: Array<HudsonMasterComputer>;
    /**
     * 
     * @type {string}
     * @memberof ComputerSet
     */
    displayName?: string;
    /**
     * 
     * @type {number}
     * @memberof ComputerSet
     */
    totalExecutors?: number;
}

/**
 * 
 * @export
 * @interface DefaultCrumbIssuer
 */
export interface DefaultCrumbIssuer {
    /**
     * 
     * @type {string}
     * @memberof DefaultCrumbIssuer
     */
    _class?: string;
    /**
     * 
     * @type {string}
     * @memberof DefaultCrumbIssuer
     */
    crumb?: string;
    /**
     * 
     * @type {string}
     * @memberof DefaultCrumbIssuer
     */
    crumbRequestField?: string;
}

/**
 * 
 * @export
 * @interface DiskSpaceMonitorDescriptorDiskSpace
 */
export interface DiskSpaceMonitorDescriptorDiskSpace {
    /**
     * 
     * @type {string}
     * @memberof DiskSpaceMonitorDescriptorDiskSpace
     */
    _class?: string;
    /**
     * 
     * @type {number}
     * @memberof DiskSpaceMonitorDescriptorDiskSpace
     */
    timestamp?: number;
    /**
     * 
     * @type {string}
     * @memberof DiskSpaceMonitorDescriptorDiskSpace
     */
    path?: string;
    /**
     * 
     * @type {number}
     * @memberof DiskSpaceMonitorDescriptorDiskSpace
     */
    size?: number;
}

/**
 * 
 * @export
 * @interface EmptyChangeLogSet
 */
export interface EmptyChangeLogSet {
    /**
     * 
     * @type {string}
     * @memberof EmptyChangeLogSet
     */
    _class?: string;
    /**
     * 
     * @type {string}
     * @memberof EmptyChangeLogSet
     */
    kind?: string;
}

/**
 * 
 * @export
 * @interface ExtensionClassContainerImpl1
 */
export interface ExtensionClassContainerImpl1 {
    /**
     * 
     * @type {string}
     * @memberof ExtensionClassContainerImpl1
     */
    _class?: string;
    /**
     * 
     * @type {ExtensionClassContainerImpl1links}
     * @memberof ExtensionClassContainerImpl1
     */
    links?: ExtensionClassContainerImpl1links;
    /**
     * 
     * @type {ExtensionClassContainerImpl1map}
     * @memberof ExtensionClassContainerImpl1
     */
    map?: ExtensionClassContainerImpl1map;
}

/**
 * 
 * @export
 * @interface ExtensionClassContainerImpl1links
 */
export interface ExtensionClassContainerImpl1links {
    /**
     * 
     * @type {Link}
     * @memberof ExtensionClassContainerImpl1links
     */
    self?: Link;
    /**
     * 
     * @type {string}
     * @memberof ExtensionClassContainerImpl1links
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface ExtensionClassContainerImpl1map
 */
export interface ExtensionClassContainerImpl1map {
    /**
     * 
     * @type {ExtensionClassImpl}
     * @memberof ExtensionClassContainerImpl1map
     */
    ioJenkinsBlueoceanServiceEmbeddedRestPipelineImpl?: ExtensionClassImpl;
    /**
     * 
     * @type {ExtensionClassImpl}
     * @memberof ExtensionClassContainerImpl1map
     */
    ioJenkinsBlueoceanServiceEmbeddedRestMultiBranchPipelineImpl?: ExtensionClassImpl;
    /**
     * 
     * @type {string}
     * @memberof ExtensionClassContainerImpl1map
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface ExtensionClassImpl
 */
export interface ExtensionClassImpl {
    /**
     * 
     * @type {string}
     * @memberof ExtensionClassImpl
     */
    _class?: string;
    /**
     * 
     * @type {ExtensionClassImpllinks}
     * @memberof ExtensionClassImpl
     */
    links?: ExtensionClassImpllinks;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExtensionClassImpl
     */
    classes?: Array<string>;
}

/**
 * 
 * @export
 * @interface ExtensionClassImpllinks
 */
export interface ExtensionClassImpllinks {
    /**
     * 
     * @type {Link}
     * @memberof ExtensionClassImpllinks
     */
    self?: Link;
    /**
     * 
     * @type {string}
     * @memberof ExtensionClassImpllinks
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface FavoriteImpl
 */
export interface FavoriteImpl {
    /**
     * 
     * @type {string}
     * @memberof FavoriteImpl
     */
    _class?: string;
    /**
     * 
     * @type {FavoriteImpllinks}
     * @memberof FavoriteImpl
     */
    links?: FavoriteImpllinks;
    /**
     * 
     * @type {PipelineImpl}
     * @memberof FavoriteImpl
     */
    item?: PipelineImpl;
}

/**
 * 
 * @export
 * @interface FavoriteImpllinks
 */
export interface FavoriteImpllinks {
    /**
     * 
     * @type {Link}
     * @memberof FavoriteImpllinks
     */
    self?: Link;
    /**
     * 
     * @type {string}
     * @memberof FavoriteImpllinks
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface FreeStyleBuild
 */
export interface FreeStyleBuild {
    /**
     * 
     * @type {string}
     * @memberof FreeStyleBuild
     */
    _class?: string;
    /**
     * 
     * @type {number}
     * @memberof FreeStyleBuild
     */
    number?: number;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleBuild
     */
    url?: string;
    /**
     * 
     * @type {Array<CauseAction>}
     * @memberof FreeStyleBuild
     */
    actions?: Array<CauseAction>;
    /**
     * 
     * @type {boolean}
     * @memberof FreeStyleBuild
     */
    building?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleBuild
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleBuild
     */
    displayName?: string;
    /**
     * 
     * @type {number}
     * @memberof FreeStyleBuild
     */
    duration?: number;
    /**
     * 
     * @type {number}
     * @memberof FreeStyleBuild
     */
    estimatedDuration?: number;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleBuild
     */
    executor?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleBuild
     */
    fullDisplayName?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleBuild
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FreeStyleBuild
     */
    keepLog?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FreeStyleBuild
     */
    queueId?: number;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleBuild
     */
    result?: string;
    /**
     * 
     * @type {number}
     * @memberof FreeStyleBuild
     */
    timestamp?: number;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleBuild
     */
    builtOn?: string;
    /**
     * 
     * @type {EmptyChangeLogSet}
     * @memberof FreeStyleBuild
     */
    changeSet?: EmptyChangeLogSet;
}

/**
 * 
 * @export
 * @interface FreeStyleProject
 */
export interface FreeStyleProject {
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    _class?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    color?: string;
    /**
     * 
     * @type {Array<FreeStyleProjectactions>}
     * @memberof FreeStyleProject
     */
    actions?: Array<FreeStyleProjectactions>;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    displayNameOrNull?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    fullDisplayName?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    fullName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FreeStyleProject
     */
    buildable?: boolean;
    /**
     * 
     * @type {Array<FreeStyleBuild>}
     * @memberof FreeStyleProject
     */
    builds?: Array<FreeStyleBuild>;
    /**
     * 
     * @type {FreeStyleBuild}
     * @memberof FreeStyleProject
     */
    firstBuild?: FreeStyleBuild;
    /**
     * 
     * @type {Array<FreeStyleProjecthealthReport>}
     * @memberof FreeStyleProject
     */
    healthReport?: Array<FreeStyleProjecthealthReport>;
    /**
     * 
     * @type {boolean}
     * @memberof FreeStyleProject
     */
    inQueue?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FreeStyleProject
     */
    keepDependencies?: boolean;
    /**
     * 
     * @type {FreeStyleBuild}
     * @memberof FreeStyleProject
     */
    lastBuild?: FreeStyleBuild;
    /**
     * 
     * @type {FreeStyleBuild}
     * @memberof FreeStyleProject
     */
    lastCompletedBuild?: FreeStyleBuild;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    lastFailedBuild?: string;
    /**
     * 
     * @type {FreeStyleBuild}
     * @memberof FreeStyleProject
     */
    lastStableBuild?: FreeStyleBuild;
    /**
     * 
     * @type {FreeStyleBuild}
     * @memberof FreeStyleProject
     */
    lastSuccessfulBuild?: FreeStyleBuild;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    lastUnstableBuild?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    lastUnsuccessfulBuild?: string;
    /**
     * 
     * @type {number}
     * @memberof FreeStyleProject
     */
    nextBuildNumber?: number;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    queueItem?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FreeStyleProject
     */
    concurrentBuild?: boolean;
    /**
     * 
     * @type {NullSCM}
     * @memberof FreeStyleProject
     */
    scm?: NullSCM;
}

/**
 * 
 * @export
 * @interface FreeStyleProjectactions
 */
export interface FreeStyleProjectactions {
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProjectactions
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface FreeStyleProjecthealthReport
 */
export interface FreeStyleProjecthealthReport {
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProjecthealthReport
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProjecthealthReport
     */
    iconClassName?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProjecthealthReport
     */
    iconUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof FreeStyleProjecthealthReport
     */
    score?: number;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProjecthealthReport
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface GenericResource
 */
export interface GenericResource {
    /**
     * 
     * @type {string}
     * @memberof GenericResource
     */
    _class?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericResource
     */
    displayName?: string;
    /**
     * 
     * @type {number}
     * @memberof GenericResource
     */
    durationInMillis?: number;
    /**
     * 
     * @type {string}
     * @memberof GenericResource
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericResource
     */
    result?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericResource
     */
    startTime?: string;
}

/**
 * 
 * @export
 * @interface GithubContent
 */
export interface GithubContent {
    /**
     * 
     * @type {string}
     * @memberof GithubContent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubContent
     */
    sha?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubContent
     */
    _class?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubContent
     */
    repo?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubContent
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubContent
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubContent
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubContent
     */
    base64Data?: string;
}

/**
 * 
 * @export
 * @interface GithubFile
 */
export interface GithubFile {
    /**
     * 
     * @type {GithubContent}
     * @memberof GithubFile
     */
    content?: GithubContent;
    /**
     * 
     * @type {string}
     * @memberof GithubFile
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface GithubOrganization
 */
export interface GithubOrganization {
    /**
     * 
     * @type {string}
     * @memberof GithubOrganization
     */
    _class?: string;
    /**
     * 
     * @type {GithubOrganizationlinks}
     * @memberof GithubOrganization
     */
    links?: GithubOrganizationlinks;
    /**
     * 
     * @type {boolean}
     * @memberof GithubOrganization
     */
    jenkinsOrganizationPipeline?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GithubOrganization
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface GithubOrganizationlinks
 */
export interface GithubOrganizationlinks {
    /**
     * 
     * @type {Link}
     * @memberof GithubOrganizationlinks
     */
    repositories?: Link;
    /**
     * 
     * @type {Link}
     * @memberof GithubOrganizationlinks
     */
    self?: Link;
    /**
     * 
     * @type {string}
     * @memberof GithubOrganizationlinks
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface GithubRepositories
 */
export interface GithubRepositories {
    /**
     * 
     * @type {string}
     * @memberof GithubRepositories
     */
    _class?: string;
    /**
     * 
     * @type {GithubRepositorieslinks}
     * @memberof GithubRepositories
     */
    links?: GithubRepositorieslinks;
    /**
     * 
     * @type {Array<GithubRepository>}
     * @memberof GithubRepositories
     */
    items?: Array<GithubRepository>;
    /**
     * 
     * @type {number}
     * @memberof GithubRepositories
     */
    lastPage?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubRepositories
     */
    nextPage?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubRepositories
     */
    pageSize?: number;
}

/**
 * 
 * @export
 * @interface GithubRepositorieslinks
 */
export interface GithubRepositorieslinks {
    /**
     * 
     * @type {Link}
     * @memberof GithubRepositorieslinks
     */
    self?: Link;
    /**
     * 
     * @type {string}
     * @memberof GithubRepositorieslinks
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface GithubRepository
 */
export interface GithubRepository {
    /**
     * 
     * @type {string}
     * @memberof GithubRepository
     */
    _class?: string;
    /**
     * 
     * @type {GithubRepositorylinks}
     * @memberof GithubRepository
     */
    links?: GithubRepositorylinks;
    /**
     * 
     * @type {string}
     * @memberof GithubRepository
     */
    defaultBranch?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubRepository
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubRepository
     */
    name?: string;
    /**
     * 
     * @type {GithubRepositorypermissions}
     * @memberof GithubRepository
     */
    permissions?: GithubRepositorypermissions;
    /**
     * 
     * @type {boolean}
     * @memberof GithubRepository
     */
    _private?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GithubRepository
     */
    fullName?: string;
}

/**
 * 
 * @export
 * @interface GithubRepositorylinks
 */
export interface GithubRepositorylinks {
    /**
     * 
     * @type {Link}
     * @memberof GithubRepositorylinks
     */
    self?: Link;
    /**
     * 
     * @type {string}
     * @memberof GithubRepositorylinks
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface GithubRepositorypermissions
 */
export interface GithubRepositorypermissions {
    /**
     * 
     * @type {boolean}
     * @memberof GithubRepositorypermissions
     */
    admin?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GithubRepositorypermissions
     */
    push?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GithubRepositorypermissions
     */
    pull?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GithubRepositorypermissions
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface GithubRespositoryContainer
 */
export interface GithubRespositoryContainer {
    /**
     * 
     * @type {string}
     * @memberof GithubRespositoryContainer
     */
    _class?: string;
    /**
     * 
     * @type {GithubRespositoryContainerlinks}
     * @memberof GithubRespositoryContainer
     */
    links?: GithubRespositoryContainerlinks;
    /**
     * 
     * @type {GithubRepositories}
     * @memberof GithubRespositoryContainer
     */
    repositories?: GithubRepositories;
}

/**
 * 
 * @export
 * @interface GithubRespositoryContainerlinks
 */
export interface GithubRespositoryContainerlinks {
    /**
     * 
     * @type {Link}
     * @memberof GithubRespositoryContainerlinks
     */
    self?: Link;
    /**
     * 
     * @type {string}
     * @memberof GithubRespositoryContainerlinks
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface GithubScm
 */
export interface GithubScm {
    /**
     * 
     * @type {string}
     * @memberof GithubScm
     */
    _class?: string;
    /**
     * 
     * @type {GithubScmlinks}
     * @memberof GithubScm
     */
    links?: GithubScmlinks;
    /**
     * 
     * @type {string}
     * @memberof GithubScm
     */
    credentialId?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubScm
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubScm
     */
    uri?: string;
}

/**
 * 
 * @export
 * @interface GithubScmlinks
 */
export interface GithubScmlinks {
    /**
     * 
     * @type {Link}
     * @memberof GithubScmlinks
     */
    self?: Link;
    /**
     * 
     * @type {string}
     * @memberof GithubScmlinks
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface Hudson
 */
export interface Hudson {
    /**
     * 
     * @type {string}
     * @memberof Hudson
     */
    _class?: string;
    /**
     * 
     * @type {Array<HudsonassignedLabels>}
     * @memberof Hudson
     */
    assignedLabels?: Array<HudsonassignedLabels>;
    /**
     * 
     * @type {string}
     * @memberof Hudson
     */
    mode?: string;
    /**
     * 
     * @type {string}
     * @memberof Hudson
     */
    nodeDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof Hudson
     */
    nodeName?: string;
    /**
     * 
     * @type {number}
     * @memberof Hudson
     */
    numExecutors?: number;
    /**
     * 
     * @type {string}
     * @memberof Hudson
     */
    description?: string;
    /**
     * 
     * @type {Array<FreeStyleProject>}
     * @memberof Hudson
     */
    jobs?: Array<FreeStyleProject>;
    /**
     * 
     * @type {AllView}
     * @memberof Hudson
     */
    primaryView?: AllView;
    /**
     * 
     * @type {boolean}
     * @memberof Hudson
     */
    quietingDown?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Hudson
     */
    slaveAgentPort?: number;
    /**
     * 
     * @type {UnlabeledLoadStatistics}
     * @memberof Hudson
     */
    unlabeledLoad?: UnlabeledLoadStatistics;
    /**
     * 
     * @type {boolean}
     * @memberof Hudson
     */
    useCrumbs?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Hudson
     */
    useSecurity?: boolean;
    /**
     * 
     * @type {Array<AllView>}
     * @memberof Hudson
     */
    views?: Array<AllView>;
}

/**
 * 
 * @export
 * @interface HudsonMasterComputer
 */
export interface HudsonMasterComputer {
    /**
     * 
     * @type {string}
     * @memberof HudsonMasterComputer
     */
    _class?: string;
    /**
     * 
     * @type {string}
     * @memberof HudsonMasterComputer
     */
    displayName?: string;
    /**
     * 
     * @type {Array<HudsonMasterComputerexecutors>}
     * @memberof HudsonMasterComputer
     */
    executors?: Array<HudsonMasterComputerexecutors>;
    /**
     * 
     * @type {string}
     * @memberof HudsonMasterComputer
     */
    icon?: string;
    /**
     * 
     * @type {string}
     * @memberof HudsonMasterComputer
     */
    iconClassName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof HudsonMasterComputer
     */
    idle?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HudsonMasterComputer
     */
    jnlpAgent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HudsonMasterComputer
     */
    launchSupported?: boolean;
    /**
     * 
     * @type {Label1}
     * @memberof HudsonMasterComputer
     */
    loadStatistics?: Label1;
    /**
     * 
     * @type {boolean}
     * @memberof HudsonMasterComputer
     */
    manualLaunchAllowed?: boolean;
    /**
     * 
     * @type {HudsonMasterComputermonitorData}
     * @memberof HudsonMasterComputer
     */
    monitorData?: HudsonMasterComputermonitorData;
    /**
     * 
     * @type {number}
     * @memberof HudsonMasterComputer
     */
    numExecutors?: number;
    /**
     * 
     * @type {boolean}
     * @memberof HudsonMasterComputer
     */
    offline?: boolean;
    /**
     * 
     * @type {string}
     * @memberof HudsonMasterComputer
     */
    offlineCause?: string;
    /**
     * 
     * @type {string}
     * @memberof HudsonMasterComputer
     */
    offlineCauseReason?: string;
    /**
     * 
     * @type {boolean}
     * @memberof HudsonMasterComputer
     */
    temporarilyOffline?: boolean;
}

/**
 * 
 * @export
 * @interface HudsonMasterComputerexecutors
 */
export interface HudsonMasterComputerexecutors {
    /**
     * 
     * @type {FreeStyleBuild}
     * @memberof HudsonMasterComputerexecutors
     */
    currentExecutable?: FreeStyleBuild;
    /**
     * 
     * @type {boolean}
     * @memberof HudsonMasterComputerexecutors
     */
    idle?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HudsonMasterComputerexecutors
     */
    likelyStuck?: boolean;
    /**
     * 
     * @type {number}
     * @memberof HudsonMasterComputerexecutors
     */
    number?: number;
    /**
     * 
     * @type {number}
     * @memberof HudsonMasterComputerexecutors
     */
    progress?: number;
    /**
     * 
     * @type {string}
     * @memberof HudsonMasterComputerexecutors
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface HudsonMasterComputermonitorData
 */
export interface HudsonMasterComputermonitorData {
    /**
     * 
     * @type {SwapSpaceMonitorMemoryUsage2}
     * @memberof HudsonMasterComputermonitorData
     */
    hudsonNodeMonitorsSwapSpaceMonitor?: SwapSpaceMonitorMemoryUsage2;
    /**
     * 
     * @type {DiskSpaceMonitorDescriptorDiskSpace}
     * @memberof HudsonMasterComputermonitorData
     */
    hudsonNodeMonitorsTemporarySpaceMonitor?: DiskSpaceMonitorDescriptorDiskSpace;
    /**
     * 
     * @type {DiskSpaceMonitorDescriptorDiskSpace}
     * @memberof HudsonMasterComputermonitorData
     */
    hudsonNodeMonitorsDiskSpaceMonitor?: DiskSpaceMonitorDescriptorDiskSpace;
    /**
     * 
     * @type {string}
     * @memberof HudsonMasterComputermonitorData
     */
    hudsonNodeMonitorsArchitectureMonitor?: string;
    /**
     * 
     * @type {ResponseTimeMonitorData}
     * @memberof HudsonMasterComputermonitorData
     */
    hudsonNodeMonitorsResponseTimeMonitor?: ResponseTimeMonitorData;
    /**
     * 
     * @type {ClockDifference}
     * @memberof HudsonMasterComputermonitorData
     */
    hudsonNodeMonitorsClockMonitor?: ClockDifference;
    /**
     * 
     * @type {string}
     * @memberof HudsonMasterComputermonitorData
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface HudsonassignedLabels
 */
export interface HudsonassignedLabels {
    /**
     * 
     * @type {string}
     * @memberof HudsonassignedLabels
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface InputStepImpl
 */
export interface InputStepImpl {
    /**
     * 
     * @type {string}
     * @memberof InputStepImpl
     */
    _class?: string;
    /**
     * 
     * @type {InputStepImpllinks}
     * @memberof InputStepImpl
     */
    links?: InputStepImpllinks;
    /**
     * 
     * @type {string}
     * @memberof InputStepImpl
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof InputStepImpl
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof InputStepImpl
     */
    ok?: string;
    /**
     * 
     * @type {Array<StringParameterDefinition>}
     * @memberof InputStepImpl
     */
    parameters?: Array<StringParameterDefinition>;
    /**
     * 
     * @type {string}
     * @memberof InputStepImpl
     */
    submitter?: string;
}

/**
 * 
 * @export
 * @interface InputStepImpllinks
 */
export interface InputStepImpllinks {
    /**
     * 
     * @type {Link}
     * @memberof InputStepImpllinks
     */
    self?: Link;
    /**
     * 
     * @type {string}
     * @memberof InputStepImpllinks
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface Label1
 */
export interface Label1 {
    /**
     * 
     * @type {string}
     * @memberof Label1
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    _class?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    href?: string;
}

/**
 * 
 * @export
 * @interface ListView
 */
export interface ListView {
    /**
     * 
     * @type {string}
     * @memberof ListView
     */
    _class?: string;
    /**
     * 
     * @type {string}
     * @memberof ListView
     */
    description?: string;
    /**
     * 
     * @type {Array<FreeStyleProject>}
     * @memberof ListView
     */
    jobs?: Array<FreeStyleProject>;
    /**
     * 
     * @type {string}
     * @memberof ListView
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ListView
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface MultibranchPipeline
 */
export interface MultibranchPipeline {
    /**
     * 
     * @type {string}
     * @memberof MultibranchPipeline
     */
    displayName?: string;
    /**
     * 
     * @type {number}
     * @memberof MultibranchPipeline
     */
    estimatedDurationInMillis?: number;
    /**
     * 
     * @type {string}
     * @memberof MultibranchPipeline
     */
    latestRun?: string;
    /**
     * 
     * @type {string}
     * @memberof MultibranchPipeline
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof MultibranchPipeline
     */
    organization?: string;
    /**
     * 
     * @type {number}
     * @memberof MultibranchPipeline
     */
    weatherScore?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof MultibranchPipeline
     */
    branchNames?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof MultibranchPipeline
     */
    numberOfFailingBranches?: number;
    /**
     * 
     * @type {number}
     * @memberof MultibranchPipeline
     */
    numberOfFailingPullRequests?: number;
    /**
     * 
     * @type {number}
     * @memberof MultibranchPipeline
     */
    numberOfSuccessfulBranches?: number;
    /**
     * 
     * @type {number}
     * @memberof MultibranchPipeline
     */
    numberOfSuccessfulPullRequests?: number;
    /**
     * 
     * @type {number}
     * @memberof MultibranchPipeline
     */
    totalNumberOfBranches?: number;
    /**
     * 
     * @type {number}
     * @memberof MultibranchPipeline
     */
    totalNumberOfPullRequests?: number;
    /**
     * 
     * @type {string}
     * @memberof MultibranchPipeline
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface NullSCM
 */
export interface NullSCM {
    /**
     * 
     * @type {string}
     * @memberof NullSCM
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface Organisation
 */
export interface Organisation {
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    _class?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface Organisations
 */
export interface Organisations extends Array<Organisation> {
}

/**
 * 
 * @export
 * @interface Pipeline
 */
export interface Pipeline {
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    _class?: string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    organization?: string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    fullName?: string;
    /**
     * 
     * @type {number}
     * @memberof Pipeline
     */
    weatherScore?: number;
    /**
     * 
     * @type {number}
     * @memberof Pipeline
     */
    estimatedDurationInMillis?: number;
    /**
     * 
     * @type {PipelinelatestRun}
     * @memberof Pipeline
     */
    latestRun?: PipelinelatestRun;
}

/**
 * 
 * @export
 * @interface PipelineActivities
 */
export interface PipelineActivities extends Array<PipelineActivity> {
}

/**
 * 
 * @export
 * @interface PipelineActivity
 */
export interface PipelineActivity {
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    _class?: string;
    /**
     * 
     * @type {Array<PipelineActivityartifacts>}
     * @memberof PipelineActivity
     */
    artifacts?: Array<PipelineActivityartifacts>;
    /**
     * 
     * @type {number}
     * @memberof PipelineActivity
     */
    durationInMillis?: number;
    /**
     * 
     * @type {number}
     * @memberof PipelineActivity
     */
    estimatedDurationInMillis?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    enQueueTime?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    endTime?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    organization?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    pipeline?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    result?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    runSummary?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    startTime?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    commitId?: string;
}

/**
 * 
 * @export
 * @interface PipelineActivityartifacts
 */
export interface PipelineActivityartifacts {
    /**
     * 
     * @type {string}
     * @memberof PipelineActivityartifacts
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelineActivityartifacts
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivityartifacts
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivityartifacts
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface PipelineBranches
 */
export interface PipelineBranches extends Array<PipelineBranchesitem> {
}

/**
 * 
 * @export
 * @interface PipelineBranchesitem
 */
export interface PipelineBranchesitem {
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitem
     */
    displayName?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelineBranchesitem
     */
    estimatedDurationInMillis?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitem
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelineBranchesitem
     */
    weatherScore?: number;
    /**
     * 
     * @type {PipelineBranchesitemlatestRun}
     * @memberof PipelineBranchesitem
     */
    latestRun?: PipelineBranchesitemlatestRun;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitem
     */
    organization?: string;
    /**
     * 
     * @type {PipelineBranchesitempullRequest}
     * @memberof PipelineBranchesitem
     */
    pullRequest?: PipelineBranchesitempullRequest;
    /**
     * 
     * @type {number}
     * @memberof PipelineBranchesitem
     */
    totalNumberOfPullRequests?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitem
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface PipelineBranchesitemlatestRun
 */
export interface PipelineBranchesitemlatestRun {
    /**
     * 
     * @type {number}
     * @memberof PipelineBranchesitemlatestRun
     */
    durationInMillis?: number;
    /**
     * 
     * @type {number}
     * @memberof PipelineBranchesitemlatestRun
     */
    estimatedDurationInMillis?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    enQueueTime?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    endTime?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    organization?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    pipeline?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    result?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    runSummary?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    startTime?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    commitId?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface PipelineBranchesitempullRequest
 */
export interface PipelineBranchesitempullRequest {
    /**
     * 
     * @type {PipelineBranchesitempullRequestlinks}
     * @memberof PipelineBranchesitempullRequest
     */
    links?: PipelineBranchesitempullRequestlinks;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitempullRequest
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitempullRequest
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitempullRequest
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitempullRequest
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitempullRequest
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface PipelineBranchesitempullRequestlinks
 */
export interface PipelineBranchesitempullRequestlinks {
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitempullRequestlinks
     */
    self?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitempullRequestlinks
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface PipelineFolderImpl
 */
export interface PipelineFolderImpl {
    /**
     * 
     * @type {string}
     * @memberof PipelineFolderImpl
     */
    _class?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineFolderImpl
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineFolderImpl
     */
    fullName?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineFolderImpl
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineFolderImpl
     */
    organization?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelineFolderImpl
     */
    numberOfFolders?: number;
    /**
     * 
     * @type {number}
     * @memberof PipelineFolderImpl
     */
    numberOfPipelines?: number;
}

/**
 * 
 * @export
 * @interface PipelineImpl
 */
export interface PipelineImpl {
    /**
     * 
     * @type {string}
     * @memberof PipelineImpl
     */
    _class?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineImpl
     */
    displayName?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelineImpl
     */
    estimatedDurationInMillis?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineImpl
     */
    fullName?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineImpl
     */
    latestRun?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineImpl
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineImpl
     */
    organization?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelineImpl
     */
    weatherScore?: number;
    /**
     * 
     * @type {PipelineImpllinks}
     * @memberof PipelineImpl
     */
    links?: PipelineImpllinks;
}

/**
 * 
 * @export
 * @interface PipelineImpllinks
 */
export interface PipelineImpllinks {
    /**
     * 
     * @type {Link}
     * @memberof PipelineImpllinks
     */
    runs?: Link;
    /**
     * 
     * @type {Link}
     * @memberof PipelineImpllinks
     */
    self?: Link;
    /**
     * 
     * @type {Link}
     * @memberof PipelineImpllinks
     */
    queue?: Link;
    /**
     * 
     * @type {Link}
     * @memberof PipelineImpllinks
     */
    actions?: Link;
    /**
     * 
     * @type {string}
     * @memberof PipelineImpllinks
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface PipelineQueue
 */
export interface PipelineQueue extends Array<QueueItemImpl> {
}

/**
 * 
 * @export
 * @interface PipelineRun
 */
export interface PipelineRun {
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    _class?: string;
    /**
     * 
     * @type {Array<PipelineRunartifacts>}
     * @memberof PipelineRun
     */
    artifacts?: Array<PipelineRunartifacts>;
    /**
     * 
     * @type {number}
     * @memberof PipelineRun
     */
    durationInMillis?: number;
    /**
     * 
     * @type {number}
     * @memberof PipelineRun
     */
    estimatedDurationInMillis?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    enQueueTime?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    endTime?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    organization?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    pipeline?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    result?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    runSummary?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    startTime?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    commitId?: string;
}

/**
 * 
 * @export
 * @interface PipelineRunImpl
 */
export interface PipelineRunImpl {
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    _class?: string;
    /**
     * 
     * @type {PipelineRunImpllinks}
     * @memberof PipelineRunImpl
     */
    links?: PipelineRunImpllinks;
    /**
     * 
     * @type {number}
     * @memberof PipelineRunImpl
     */
    durationInMillis?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    enQueueTime?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    endTime?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelineRunImpl
     */
    estimatedDurationInMillis?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    organization?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    pipeline?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    result?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    runSummary?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    startTime?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    commitId?: string;
}

/**
 * 
 * @export
 * @interface PipelineRunImpllinks
 */
export interface PipelineRunImpllinks {
    /**
     * 
     * @type {Link}
     * @memberof PipelineRunImpllinks
     */
    nodes?: Link;
    /**
     * 
     * @type {Link}
     * @memberof PipelineRunImpllinks
     */
    log?: Link;
    /**
     * 
     * @type {Link}
     * @memberof PipelineRunImpllinks
     */
    self?: Link;
    /**
     * 
     * @type {Link}
     * @memberof PipelineRunImpllinks
     */
    actions?: Link;
    /**
     * 
     * @type {Link}
     * @memberof PipelineRunImpllinks
     */
    steps?: Link;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpllinks
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface PipelineRunNode
 */
export interface PipelineRunNode {
    /**
     * 
     * @type {string}
     * @memberof PipelineRunNode
     */
    _class?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunNode
     */
    displayName?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelineRunNode
     */
    durationInMillis?: number;
    /**
     * 
     * @type {Array<PipelineRunNodeedges>}
     * @memberof PipelineRunNode
     */
    edges?: Array<PipelineRunNodeedges>;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunNode
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunNode
     */
    result?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunNode
     */
    startTime?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunNode
     */
    state?: string;
}

/**
 * 
 * @export
 * @interface PipelineRunNodeSteps
 */
export interface PipelineRunNodeSteps extends Array<PipelineStepImpl> {
}

/**
 * 
 * @export
 * @interface PipelineRunNodeedges
 */
export interface PipelineRunNodeedges {
    /**
     * 
     * @type {string}
     * @memberof PipelineRunNodeedges
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunNodeedges
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface PipelineRunNodes
 */
export interface PipelineRunNodes extends Array<PipelineRunNode> {
}

/**
 * 
 * @export
 * @interface PipelineRunSteps
 */
export interface PipelineRunSteps extends Array<GenericResource> {
}

/**
 * 
 * @export
 * @interface PipelineRunartifacts
 */
export interface PipelineRunartifacts {
    /**
     * 
     * @type {string}
     * @memberof PipelineRunartifacts
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelineRunartifacts
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunartifacts
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunartifacts
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface PipelineRuns
 */
export interface PipelineRuns extends Array<PipelineRun> {
}

/**
 * 
 * @export
 * @interface PipelineStepImpl
 */
export interface PipelineStepImpl {
    /**
     * 
     * @type {string}
     * @memberof PipelineStepImpl
     */
    _class?: string;
    /**
     * 
     * @type {PipelineStepImpllinks}
     * @memberof PipelineStepImpl
     */
    links?: PipelineStepImpllinks;
    /**
     * 
     * @type {string}
     * @memberof PipelineStepImpl
     */
    displayName?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelineStepImpl
     */
    durationInMillis?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineStepImpl
     */
    id?: string;
    /**
     * 
     * @type {InputStepImpl}
     * @memberof PipelineStepImpl
     */
    input?: InputStepImpl;
    /**
     * 
     * @type {string}
     * @memberof PipelineStepImpl
     */
    result?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineStepImpl
     */
    startTime?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineStepImpl
     */
    state?: string;
}

/**
 * 
 * @export
 * @interface PipelineStepImpllinks
 */
export interface PipelineStepImpllinks {
    /**
     * 
     * @type {Link}
     * @memberof PipelineStepImpllinks
     */
    self?: Link;
    /**
     * 
     * @type {Link}
     * @memberof PipelineStepImpllinks
     */
    actions?: Link;
    /**
     * 
     * @type {string}
     * @memberof PipelineStepImpllinks
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface PipelinelatestRun
 */
export interface PipelinelatestRun {
    /**
     * 
     * @type {Array<PipelinelatestRunartifacts>}
     * @memberof PipelinelatestRun
     */
    artifacts?: Array<PipelinelatestRunartifacts>;
    /**
     * 
     * @type {number}
     * @memberof PipelinelatestRun
     */
    durationInMillis?: number;
    /**
     * 
     * @type {number}
     * @memberof PipelinelatestRun
     */
    estimatedDurationInMillis?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    enQueueTime?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    endTime?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    organization?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    pipeline?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    result?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    runSummary?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    startTime?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    commitId?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface PipelinelatestRunartifacts
 */
export interface PipelinelatestRunartifacts {
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRunartifacts
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelinelatestRunartifacts
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRunartifacts
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRunartifacts
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface Pipelines
 */
export interface Pipelines extends Array<Pipeline> {
}

/**
 * 
 * @export
 * @interface Queue
 */
export interface Queue {
    /**
     * 
     * @type {string}
     * @memberof Queue
     */
    _class?: string;
    /**
     * 
     * @type {Array<QueueBlockedItem>}
     * @memberof Queue
     */
    items?: Array<QueueBlockedItem>;
}

/**
 * 
 * @export
 * @interface QueueBlockedItem
 */
export interface QueueBlockedItem {
    /**
     * 
     * @type {string}
     * @memberof QueueBlockedItem
     */
    _class?: string;
    /**
     * 
     * @type {Array<CauseAction>}
     * @memberof QueueBlockedItem
     */
    actions?: Array<CauseAction>;
    /**
     * 
     * @type {boolean}
     * @memberof QueueBlockedItem
     */
    blocked?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QueueBlockedItem
     */
    buildable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof QueueBlockedItem
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof QueueBlockedItem
     */
    inQueueSince?: number;
    /**
     * 
     * @type {string}
     * @memberof QueueBlockedItem
     */
    params?: string;
    /**
     * 
     * @type {boolean}
     * @memberof QueueBlockedItem
     */
    stuck?: boolean;
    /**
     * 
     * @type {FreeStyleProject}
     * @memberof QueueBlockedItem
     */
    task?: FreeStyleProject;
    /**
     * 
     * @type {string}
     * @memberof QueueBlockedItem
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof QueueBlockedItem
     */
    why?: string;
    /**
     * 
     * @type {number}
     * @memberof QueueBlockedItem
     */
    buildableStartMilliseconds?: number;
}

/**
 * 
 * @export
 * @interface QueueItemImpl
 */
export interface QueueItemImpl {
    /**
     * 
     * @type {string}
     * @memberof QueueItemImpl
     */
    _class?: string;
    /**
     * 
     * @type {number}
     * @memberof QueueItemImpl
     */
    expectedBuildNumber?: number;
    /**
     * 
     * @type {string}
     * @memberof QueueItemImpl
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof QueueItemImpl
     */
    pipeline?: string;
    /**
     * 
     * @type {number}
     * @memberof QueueItemImpl
     */
    queuedTime?: number;
}

/**
 * 
 * @export
 * @interface QueueLeftItem
 */
export interface QueueLeftItem {
    /**
     * 
     * @type {string}
     * @memberof QueueLeftItem
     */
    _class?: string;
    /**
     * 
     * @type {Array<CauseAction>}
     * @memberof QueueLeftItem
     */
    actions?: Array<CauseAction>;
    /**
     * 
     * @type {boolean}
     * @memberof QueueLeftItem
     */
    blocked?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QueueLeftItem
     */
    buildable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof QueueLeftItem
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof QueueLeftItem
     */
    inQueueSince?: number;
    /**
     * 
     * @type {string}
     * @memberof QueueLeftItem
     */
    params?: string;
    /**
     * 
     * @type {boolean}
     * @memberof QueueLeftItem
     */
    stuck?: boolean;
    /**
     * 
     * @type {FreeStyleProject}
     * @memberof QueueLeftItem
     */
    task?: FreeStyleProject;
    /**
     * 
     * @type {string}
     * @memberof QueueLeftItem
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof QueueLeftItem
     */
    why?: string;
    /**
     * 
     * @type {boolean}
     * @memberof QueueLeftItem
     */
    cancelled?: boolean;
    /**
     * 
     * @type {FreeStyleBuild}
     * @memberof QueueLeftItem
     */
    executable?: FreeStyleBuild;
}

/**
 * 
 * @export
 * @interface ResponseTimeMonitorData
 */
export interface ResponseTimeMonitorData {
    /**
     * 
     * @type {string}
     * @memberof ResponseTimeMonitorData
     */
    _class?: string;
    /**
     * 
     * @type {number}
     * @memberof ResponseTimeMonitorData
     */
    timestamp?: number;
    /**
     * 
     * @type {number}
     * @memberof ResponseTimeMonitorData
     */
    average?: number;
}

/**
 * 
 * @export
 * @interface ScmOrganisations
 */
export interface ScmOrganisations extends Array<GithubOrganization> {
}

/**
 * 
 * @export
 * @interface StringParameterDefinition
 */
export interface StringParameterDefinition {
    /**
     * 
     * @type {string}
     * @memberof StringParameterDefinition
     */
    _class?: string;
    /**
     * 
     * @type {StringParameterValue}
     * @memberof StringParameterDefinition
     */
    defaultParameterValue?: StringParameterValue;
    /**
     * 
     * @type {string}
     * @memberof StringParameterDefinition
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof StringParameterDefinition
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof StringParameterDefinition
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface StringParameterValue
 */
export interface StringParameterValue {
    /**
     * 
     * @type {string}
     * @memberof StringParameterValue
     */
    _class?: string;
    /**
     * 
     * @type {string}
     * @memberof StringParameterValue
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof StringParameterValue
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface SwapSpaceMonitorMemoryUsage2
 */
export interface SwapSpaceMonitorMemoryUsage2 {
    /**
     * 
     * @type {string}
     * @memberof SwapSpaceMonitorMemoryUsage2
     */
    _class?: string;
    /**
     * 
     * @type {number}
     * @memberof SwapSpaceMonitorMemoryUsage2
     */
    availablePhysicalMemory?: number;
    /**
     * 
     * @type {number}
     * @memberof SwapSpaceMonitorMemoryUsage2
     */
    availableSwapSpace?: number;
    /**
     * 
     * @type {number}
     * @memberof SwapSpaceMonitorMemoryUsage2
     */
    totalPhysicalMemory?: number;
    /**
     * 
     * @type {number}
     * @memberof SwapSpaceMonitorMemoryUsage2
     */
    totalSwapSpace?: number;
}

/**
 * 
 * @export
 * @interface UnlabeledLoadStatistics
 */
export interface UnlabeledLoadStatistics {
    /**
     * 
     * @type {string}
     * @memberof UnlabeledLoadStatistics
     */
    _class?: string;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    _class?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    fullName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface UserFavorites
 */
export interface UserFavorites extends Array<FavoriteImpl> {
}

/**
 * 
 * @export
 * @interface Users
 */
export interface Users extends Array<User> {
}


/**
 * BaseRemoteAccessApi - fetch parameter creator
 * @export
 */
export const BaseRemoteAccessApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrumb(options: any = {}): FetchArgs {
            const localVarPath = `/crumbIssuer/api/json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BaseRemoteAccessApi - functional programming interface
 * @export
 */
export const BaseRemoteAccessApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrumb(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefaultCrumbIssuer> {
            const localVarFetchArgs = BaseRemoteAccessApiFetchParamCreator(configuration).getCrumb(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BaseRemoteAccessApi - factory interface
 * @export
 */
export const BaseRemoteAccessApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrumb(options?: any) {
            return BaseRemoteAccessApiFp(configuration).getCrumb(options)(fetch, basePath);
        },
    };
};

/**
 * BaseRemoteAccessApi - object-oriented interface
 * @export
 * @class BaseRemoteAccessApi
 * @extends {BaseAPI}
 */
export class BaseRemoteAccessApi extends BaseAPI {
    /**
     * Retrieve CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BaseRemoteAccessApi
     */
    public getCrumb(options?: any) {
        return BaseRemoteAccessApiFp(this.configuration).getCrumb(options)(this.fetch, this.basePath);
    }

}

/**
 * BlueOceanApi - fetch parameter creator
 * @export
 */
export const BlueOceanApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete queue item from an organization pipeline queue
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} queue Name of the queue item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipelineQueueItem(organization: string, pipeline: string, queue: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling deletePipelineQueueItem.');
            }
            // verify required parameter 'pipeline' is not null or undefined
            if (pipeline === null || pipeline === undefined) {
                throw new RequiredError('pipeline','Required parameter pipeline was null or undefined when calling deletePipelineQueueItem.');
            }
            // verify required parameter 'queue' is not null or undefined
            if (queue === null || queue === undefined) {
                throw new RequiredError('queue','Required parameter queue was null or undefined when calling deletePipelineQueueItem.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue/{queue}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"queue"}}`, encodeURIComponent(String(queue)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve authenticated user details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticatedUser(organization: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getAuthenticatedUser.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/user/`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of class names supported by a given class
         * @param {string} _class Name of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClasses(_class: string, options: any = {}): FetchArgs {
            // verify required parameter '_class' is not null or undefined
            if (_class === null || _class === undefined) {
                throw new RequiredError('_class','Required parameter _class was null or undefined when calling getClasses.');
            }
            const localVarPath = `/blue/rest/classes/{class}`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve JSON Web Key
         * @param {number} key Key ID received as part of JWT header field kid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebKey(key: number, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getJsonWebKey.');
            }
            const localVarPath = `/jwt-auth/jwks/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve JSON Web Token
         * @param {number} [expiryTimeInMins] Token expiry time in minutes, default: 30 minutes
         * @param {number} [maxExpiryTimeInMins] Maximum token expiry time in minutes, default: 480 minutes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebToken(expiryTimeInMins?: number, maxExpiryTimeInMins?: number, options: any = {}): FetchArgs {
            const localVarPath = `/jwt-auth/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expiryTimeInMins !== undefined) {
                localVarQueryParameter['expiryTimeInMins'] = expiryTimeInMins;
            }

            if (maxExpiryTimeInMins !== undefined) {
                localVarQueryParameter['maxExpiryTimeInMins'] = maxExpiryTimeInMins;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve organization details
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisation(organization: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getOrganisation.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all organizations details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisations(options: any = {}): FetchArgs {
            const localVarPath = `/blue/rest/organizations/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve pipeline details for an organization
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipeline(organization: string, pipeline: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getPipeline.');
            }
            // verify required parameter 'pipeline' is not null or undefined
            if (pipeline === null || pipeline === undefined) {
                throw new RequiredError('pipeline','Required parameter pipeline was null or undefined when calling getPipeline.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all activities details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineActivities(organization: string, pipeline: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getPipelineActivities.');
            }
            // verify required parameter 'pipeline' is not null or undefined
            if (pipeline === null || pipeline === undefined) {
                throw new RequiredError('pipeline','Required parameter pipeline was null or undefined when calling getPipelineActivities.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/activities`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve branch details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} branch Name of the branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineBranch(organization: string, pipeline: string, branch: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getPipelineBranch.');
            }
            // verify required parameter 'pipeline' is not null or undefined
            if (pipeline === null || pipeline === undefined) {
                throw new RequiredError('pipeline','Required parameter pipeline was null or undefined when calling getPipelineBranch.');
            }
            // verify required parameter 'branch' is not null or undefined
            if (branch === null || branch === undefined) {
                throw new RequiredError('branch','Required parameter branch was null or undefined when calling getPipelineBranch.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve branch run details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} branch Name of the branch
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineBranchRun(organization: string, pipeline: string, branch: string, run: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getPipelineBranchRun.');
            }
            // verify required parameter 'pipeline' is not null or undefined
            if (pipeline === null || pipeline === undefined) {
                throw new RequiredError('pipeline','Required parameter pipeline was null or undefined when calling getPipelineBranchRun.');
            }
            // verify required parameter 'branch' is not null or undefined
            if (branch === null || branch === undefined) {
                throw new RequiredError('branch','Required parameter branch was null or undefined when calling getPipelineBranchRun.');
            }
            // verify required parameter 'run' is not null or undefined
            if (run === null || run === undefined) {
                throw new RequiredError('run','Required parameter run was null or undefined when calling getPipelineBranchRun.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/runs/{run}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all branches details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineBranches(organization: string, pipeline: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getPipelineBranches.');
            }
            // verify required parameter 'pipeline' is not null or undefined
            if (pipeline === null || pipeline === undefined) {
                throw new RequiredError('pipeline','Required parameter pipeline was null or undefined when calling getPipelineBranches.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve pipeline folder for an organization
         * @param {string} organization Name of the organization
         * @param {string} folder Name of the folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineFolder(organization: string, folder: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getPipelineFolder.');
            }
            // verify required parameter 'folder' is not null or undefined
            if (folder === null || folder === undefined) {
                throw new RequiredError('folder','Required parameter folder was null or undefined when calling getPipelineFolder.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{folder}/`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve pipeline details for an organization folder
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} folder Name of the folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineFolderPipeline(organization: string, pipeline: string, folder: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getPipelineFolderPipeline.');
            }
            // verify required parameter 'pipeline' is not null or undefined
            if (pipeline === null || pipeline === undefined) {
                throw new RequiredError('pipeline','Required parameter pipeline was null or undefined when calling getPipelineFolderPipeline.');
            }
            // verify required parameter 'folder' is not null or undefined
            if (folder === null || folder === undefined) {
                throw new RequiredError('folder','Required parameter folder was null or undefined when calling getPipelineFolderPipeline.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{folder}/pipelines/{pipeline}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve queue details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineQueue(organization: string, pipeline: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getPipelineQueue.');
            }
            // verify required parameter 'pipeline' is not null or undefined
            if (pipeline === null || pipeline === undefined) {
                throw new RequiredError('pipeline','Required parameter pipeline was null or undefined when calling getPipelineQueue.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve run details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRun(organization: string, pipeline: string, run: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getPipelineRun.');
            }
            // verify required parameter 'pipeline' is not null or undefined
            if (pipeline === null || pipeline === undefined) {
                throw new RequiredError('pipeline','Required parameter pipeline was null or undefined when calling getPipelineRun.');
            }
            // verify required parameter 'run' is not null or undefined
            if (run === null || run === undefined) {
                throw new RequiredError('run','Required parameter run was null or undefined when calling getPipelineRun.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get log for a pipeline run
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {number} [start] Start position of the log
         * @param {boolean} [download] Set to true in order to download the file, otherwise it&#39;s passed as a response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunLog(organization: string, pipeline: string, run: string, start?: number, download?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getPipelineRunLog.');
            }
            // verify required parameter 'pipeline' is not null or undefined
            if (pipeline === null || pipeline === undefined) {
                throw new RequiredError('pipeline','Required parameter pipeline was null or undefined when calling getPipelineRunLog.');
            }
            // verify required parameter 'run' is not null or undefined
            if (run === null || run === undefined) {
                throw new RequiredError('run','Required parameter run was null or undefined when calling getPipelineRunLog.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/log`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve run node details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNode(organization: string, pipeline: string, run: string, node: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getPipelineRunNode.');
            }
            // verify required parameter 'pipeline' is not null or undefined
            if (pipeline === null || pipeline === undefined) {
                throw new RequiredError('pipeline','Required parameter pipeline was null or undefined when calling getPipelineRunNode.');
            }
            // verify required parameter 'run' is not null or undefined
            if (run === null || run === undefined) {
                throw new RequiredError('run','Required parameter run was null or undefined when calling getPipelineRunNode.');
            }
            // verify required parameter 'node' is not null or undefined
            if (node === null || node === undefined) {
                throw new RequiredError('node','Required parameter node was null or undefined when calling getPipelineRunNode.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)))
                .replace(`{${"node"}}`, encodeURIComponent(String(node)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve run node details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {string} step Name of the step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodeStep(organization: string, pipeline: string, run: string, node: string, step: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getPipelineRunNodeStep.');
            }
            // verify required parameter 'pipeline' is not null or undefined
            if (pipeline === null || pipeline === undefined) {
                throw new RequiredError('pipeline','Required parameter pipeline was null or undefined when calling getPipelineRunNodeStep.');
            }
            // verify required parameter 'run' is not null or undefined
            if (run === null || run === undefined) {
                throw new RequiredError('run','Required parameter run was null or undefined when calling getPipelineRunNodeStep.');
            }
            // verify required parameter 'node' is not null or undefined
            if (node === null || node === undefined) {
                throw new RequiredError('node','Required parameter node was null or undefined when calling getPipelineRunNodeStep.');
            }
            // verify required parameter 'step' is not null or undefined
            if (step === null || step === undefined) {
                throw new RequiredError('step','Required parameter step was null or undefined when calling getPipelineRunNodeStep.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)))
                .replace(`{${"node"}}`, encodeURIComponent(String(node)))
                .replace(`{${"step"}}`, encodeURIComponent(String(step)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get log for a pipeline run node step
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {string} step Name of the step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodeStepLog(organization: string, pipeline: string, run: string, node: string, step: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getPipelineRunNodeStepLog.');
            }
            // verify required parameter 'pipeline' is not null or undefined
            if (pipeline === null || pipeline === undefined) {
                throw new RequiredError('pipeline','Required parameter pipeline was null or undefined when calling getPipelineRunNodeStepLog.');
            }
            // verify required parameter 'run' is not null or undefined
            if (run === null || run === undefined) {
                throw new RequiredError('run','Required parameter run was null or undefined when calling getPipelineRunNodeStepLog.');
            }
            // verify required parameter 'node' is not null or undefined
            if (node === null || node === undefined) {
                throw new RequiredError('node','Required parameter node was null or undefined when calling getPipelineRunNodeStepLog.');
            }
            // verify required parameter 'step' is not null or undefined
            if (step === null || step === undefined) {
                throw new RequiredError('step','Required parameter step was null or undefined when calling getPipelineRunNodeStepLog.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}/log`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)))
                .replace(`{${"node"}}`, encodeURIComponent(String(node)))
                .replace(`{${"step"}}`, encodeURIComponent(String(step)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve run node steps details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodeSteps(organization: string, pipeline: string, run: string, node: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getPipelineRunNodeSteps.');
            }
            // verify required parameter 'pipeline' is not null or undefined
            if (pipeline === null || pipeline === undefined) {
                throw new RequiredError('pipeline','Required parameter pipeline was null or undefined when calling getPipelineRunNodeSteps.');
            }
            // verify required parameter 'run' is not null or undefined
            if (run === null || run === undefined) {
                throw new RequiredError('run','Required parameter run was null or undefined when calling getPipelineRunNodeSteps.');
            }
            // verify required parameter 'node' is not null or undefined
            if (node === null || node === undefined) {
                throw new RequiredError('node','Required parameter node was null or undefined when calling getPipelineRunNodeSteps.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)))
                .replace(`{${"node"}}`, encodeURIComponent(String(node)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve run nodes details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodes(organization: string, pipeline: string, run: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getPipelineRunNodes.');
            }
            // verify required parameter 'pipeline' is not null or undefined
            if (pipeline === null || pipeline === undefined) {
                throw new RequiredError('pipeline','Required parameter pipeline was null or undefined when calling getPipelineRunNodes.');
            }
            // verify required parameter 'run' is not null or undefined
            if (run === null || run === undefined) {
                throw new RequiredError('run','Required parameter run was null or undefined when calling getPipelineRunNodes.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all runs details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRuns(organization: string, pipeline: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getPipelineRuns.');
            }
            // verify required parameter 'pipeline' is not null or undefined
            if (pipeline === null || pipeline === undefined) {
                throw new RequiredError('pipeline','Required parameter pipeline was null or undefined when calling getPipelineRuns.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all pipelines details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelines(organization: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getPipelines.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve SCM details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCM(organization: string, scm: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getSCM.');
            }
            // verify required parameter 'scm' is not null or undefined
            if (scm === null || scm === undefined) {
                throw new RequiredError('scm','Required parameter scm was null or undefined when calling getSCM.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/scm/{scm}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"scm"}}`, encodeURIComponent(String(scm)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve SCM organization repositories details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} scmOrganisation Name of the SCM organization
         * @param {string} [credentialId] Credential ID
         * @param {number} [pageSize] Number of items in a page
         * @param {number} [pageNumber] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCMOrganisationRepositories(organization: string, scm: string, scmOrganisation: string, credentialId?: string, pageSize?: number, pageNumber?: number, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getSCMOrganisationRepositories.');
            }
            // verify required parameter 'scm' is not null or undefined
            if (scm === null || scm === undefined) {
                throw new RequiredError('scm','Required parameter scm was null or undefined when calling getSCMOrganisationRepositories.');
            }
            // verify required parameter 'scmOrganisation' is not null or undefined
            if (scmOrganisation === null || scmOrganisation === undefined) {
                throw new RequiredError('scmOrganisation','Required parameter scmOrganisation was null or undefined when calling getSCMOrganisationRepositories.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"scm"}}`, encodeURIComponent(String(scm)))
                .replace(`{${"scmOrganisation"}}`, encodeURIComponent(String(scmOrganisation)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (credentialId !== undefined) {
                localVarQueryParameter['credentialId'] = credentialId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve SCM organization repository details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} scmOrganisation Name of the SCM organization
         * @param {string} repository Name of the SCM repository
         * @param {string} [credentialId] Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCMOrganisationRepository(organization: string, scm: string, scmOrganisation: string, repository: string, credentialId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getSCMOrganisationRepository.');
            }
            // verify required parameter 'scm' is not null or undefined
            if (scm === null || scm === undefined) {
                throw new RequiredError('scm','Required parameter scm was null or undefined when calling getSCMOrganisationRepository.');
            }
            // verify required parameter 'scmOrganisation' is not null or undefined
            if (scmOrganisation === null || scmOrganisation === undefined) {
                throw new RequiredError('scmOrganisation','Required parameter scmOrganisation was null or undefined when calling getSCMOrganisationRepository.');
            }
            // verify required parameter 'repository' is not null or undefined
            if (repository === null || repository === undefined) {
                throw new RequiredError('repository','Required parameter repository was null or undefined when calling getSCMOrganisationRepository.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories/{repository}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"scm"}}`, encodeURIComponent(String(scm)))
                .replace(`{${"scmOrganisation"}}`, encodeURIComponent(String(scmOrganisation)))
                .replace(`{${"repository"}}`, encodeURIComponent(String(repository)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (credentialId !== undefined) {
                localVarQueryParameter['credentialId'] = credentialId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve SCM organizations details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} [credentialId] Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCMOrganisations(organization: string, scm: string, credentialId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getSCMOrganisations.');
            }
            // verify required parameter 'scm' is not null or undefined
            if (scm === null || scm === undefined) {
                throw new RequiredError('scm','Required parameter scm was null or undefined when calling getSCMOrganisations.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/scm/{scm}/organizations`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"scm"}}`, encodeURIComponent(String(scm)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (credentialId !== undefined) {
                localVarQueryParameter['credentialId'] = credentialId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve user details for an organization
         * @param {string} organization Name of the organization
         * @param {string} user Name of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(organization: string, user: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getUser.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling getUser.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/users/{user}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve user favorites details for an organization
         * @param {string} user Name of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFavorites(user: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling getUserFavorites.');
            }
            const localVarPath = `/blue/rest/users/{user}/favorites`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve users details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(organization: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getUsers.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/users/`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replay an organization pipeline run
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPipelineRun(organization: string, pipeline: string, run: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling postPipelineRun.');
            }
            // verify required parameter 'pipeline' is not null or undefined
            if (pipeline === null || pipeline === undefined) {
                throw new RequiredError('pipeline','Required parameter pipeline was null or undefined when calling postPipelineRun.');
            }
            // verify required parameter 'run' is not null or undefined
            if (run === null || run === undefined) {
                throw new RequiredError('run','Required parameter run was null or undefined when calling postPipelineRun.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/replay`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a build for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPipelineRuns(organization: string, pipeline: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling postPipelineRuns.');
            }
            // verify required parameter 'pipeline' is not null or undefined
            if (pipeline === null || pipeline === undefined) {
                throw new RequiredError('pipeline','Required parameter pipeline was null or undefined when calling postPipelineRuns.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Favorite/unfavorite a pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {Body} body Set JSON string body to {&quot;favorite&quot;: true} to favorite, set value to false to unfavorite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPipelineFavorite(organization: string, pipeline: string, body: Body, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling putPipelineFavorite.');
            }
            // verify required parameter 'pipeline' is not null or undefined
            if (pipeline === null || pipeline === undefined) {
                throw new RequiredError('pipeline','Required parameter pipeline was null or undefined when calling putPipelineFavorite.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putPipelineFavorite.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/favorite`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Body" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop a build of an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} [blocking] Set to true to make blocking stop, default: false
         * @param {number} [timeOutInSecs] Timeout in seconds, default: 10 seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPipelineRun(organization: string, pipeline: string, run: string, blocking?: string, timeOutInSecs?: number, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling putPipelineRun.');
            }
            // verify required parameter 'pipeline' is not null or undefined
            if (pipeline === null || pipeline === undefined) {
                throw new RequiredError('pipeline','Required parameter pipeline was null or undefined when calling putPipelineRun.');
            }
            // verify required parameter 'run' is not null or undefined
            if (run === null || run === undefined) {
                throw new RequiredError('run','Required parameter run was null or undefined when calling putPipelineRun.');
            }
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/stop`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (blocking !== undefined) {
                localVarQueryParameter['blocking'] = blocking;
            }

            if (timeOutInSecs !== undefined) {
                localVarQueryParameter['timeOutInSecs'] = timeOutInSecs;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for any resource details
         * @param {string} q Query string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(q: string, options: any = {}): FetchArgs {
            // verify required parameter 'q' is not null or undefined
            if (q === null || q === undefined) {
                throw new RequiredError('q','Required parameter q was null or undefined when calling search.');
            }
            const localVarPath = `/blue/rest/search/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get classes details
         * @param {string} q Query string containing an array of class names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchClasses(q: string, options: any = {}): FetchArgs {
            // verify required parameter 'q' is not null or undefined
            if (q === null || q === undefined) {
                throw new RequiredError('q','Required parameter q was null or undefined when calling searchClasses.');
            }
            const localVarPath = `/blue/rest/classes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlueOceanApi - functional programming interface
 * @export
 */
export const BlueOceanApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete queue item from an organization pipeline queue
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} queue Name of the queue item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipelineQueueItem(organization: string, pipeline: string, queue: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).deletePipelineQueueItem(organization, pipeline, queue, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve authenticated user details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticatedUser(organization: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getAuthenticatedUser(organization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of class names supported by a given class
         * @param {string} _class Name of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClasses(_class: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getClasses(_class, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve JSON Web Key
         * @param {number} key Key ID received as part of JWT header field kid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebKey(key: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getJsonWebKey(key, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve JSON Web Token
         * @param {number} [expiryTimeInMins] Token expiry time in minutes, default: 30 minutes
         * @param {number} [maxExpiryTimeInMins] Maximum token expiry time in minutes, default: 480 minutes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebToken(expiryTimeInMins?: number, maxExpiryTimeInMins?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getJsonWebToken(expiryTimeInMins, maxExpiryTimeInMins, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve organization details
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisation(organization: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Organisation> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getOrganisation(organization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all organizations details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisations(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Organisations> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getOrganisations(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve pipeline details for an organization
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipeline(organization: string, pipeline: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pipeline> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getPipeline(organization, pipeline, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all activities details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineActivities(organization: string, pipeline: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PipelineActivities> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getPipelineActivities(organization, pipeline, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve branch details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} branch Name of the branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineBranch(organization: string, pipeline: string, branch: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BranchImpl> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getPipelineBranch(organization, pipeline, branch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve branch run details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} branch Name of the branch
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineBranchRun(organization: string, pipeline: string, branch: string, run: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PipelineRun> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getPipelineBranchRun(organization, pipeline, branch, run, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all branches details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineBranches(organization: string, pipeline: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MultibranchPipeline> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getPipelineBranches(organization, pipeline, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve pipeline folder for an organization
         * @param {string} organization Name of the organization
         * @param {string} folder Name of the folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineFolder(organization: string, folder: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PipelineFolderImpl> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getPipelineFolder(organization, folder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve pipeline details for an organization folder
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} folder Name of the folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineFolderPipeline(organization: string, pipeline: string, folder: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PipelineImpl> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getPipelineFolderPipeline(organization, pipeline, folder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve queue details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineQueue(organization: string, pipeline: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PipelineQueue> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getPipelineQueue(organization, pipeline, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve run details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRun(organization: string, pipeline: string, run: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PipelineRun> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getPipelineRun(organization, pipeline, run, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get log for a pipeline run
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {number} [start] Start position of the log
         * @param {boolean} [download] Set to true in order to download the file, otherwise it&#39;s passed as a response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunLog(organization: string, pipeline: string, run: string, start?: number, download?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getPipelineRunLog(organization, pipeline, run, start, download, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve run node details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNode(organization: string, pipeline: string, run: string, node: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PipelineRunNode> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getPipelineRunNode(organization, pipeline, run, node, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve run node details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {string} step Name of the step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodeStep(organization: string, pipeline: string, run: string, node: string, step: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PipelineStepImpl> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getPipelineRunNodeStep(organization, pipeline, run, node, step, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get log for a pipeline run node step
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {string} step Name of the step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodeStepLog(organization: string, pipeline: string, run: string, node: string, step: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getPipelineRunNodeStepLog(organization, pipeline, run, node, step, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve run node steps details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodeSteps(organization: string, pipeline: string, run: string, node: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PipelineRunNodeSteps> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getPipelineRunNodeSteps(organization, pipeline, run, node, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve run nodes details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodes(organization: string, pipeline: string, run: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PipelineRunNodes> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getPipelineRunNodes(organization, pipeline, run, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all runs details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRuns(organization: string, pipeline: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PipelineRuns> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getPipelineRuns(organization, pipeline, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all pipelines details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelines(organization: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pipelines> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getPipelines(organization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve SCM details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCM(organization: string, scm: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GithubScm> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getSCM(organization, scm, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve SCM organization repositories details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} scmOrganisation Name of the SCM organization
         * @param {string} [credentialId] Credential ID
         * @param {number} [pageSize] Number of items in a page
         * @param {number} [pageNumber] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCMOrganisationRepositories(organization: string, scm: string, scmOrganisation: string, credentialId?: string, pageSize?: number, pageNumber?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScmOrganisations> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getSCMOrganisationRepositories(organization, scm, scmOrganisation, credentialId, pageSize, pageNumber, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve SCM organization repository details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} scmOrganisation Name of the SCM organization
         * @param {string} repository Name of the SCM repository
         * @param {string} [credentialId] Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCMOrganisationRepository(organization: string, scm: string, scmOrganisation: string, repository: string, credentialId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScmOrganisations> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getSCMOrganisationRepository(organization, scm, scmOrganisation, repository, credentialId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve SCM organizations details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} [credentialId] Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCMOrganisations(organization: string, scm: string, credentialId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScmOrganisations> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getSCMOrganisations(organization, scm, credentialId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve user details for an organization
         * @param {string} organization Name of the organization
         * @param {string} user Name of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(organization: string, user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getUser(organization, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve user favorites details for an organization
         * @param {string} user Name of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFavorites(user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserFavorites> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getUserFavorites(user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve users details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(organization: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).getUsers(organization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Replay an organization pipeline run
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPipelineRun(organization: string, pipeline: string, run: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueueItemImpl> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).postPipelineRun(organization, pipeline, run, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Start a build for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPipelineRuns(organization: string, pipeline: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueueItemImpl> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).postPipelineRuns(organization, pipeline, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Favorite/unfavorite a pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {Body} body Set JSON string body to {&quot;favorite&quot;: true} to favorite, set value to false to unfavorite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPipelineFavorite(organization: string, pipeline: string, body: Body, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FavoriteImpl> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).putPipelineFavorite(organization, pipeline, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Stop a build of an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} [blocking] Set to true to make blocking stop, default: false
         * @param {number} [timeOutInSecs] Timeout in seconds, default: 10 seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPipelineRun(organization: string, pipeline: string, run: string, blocking?: string, timeOutInSecs?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PipelineRun> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).putPipelineRun(organization, pipeline, run, blocking, timeOutInSecs, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Search for any resource details
         * @param {string} q Query string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(q: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).search(q, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get classes details
         * @param {string} q Query string containing an array of class names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchClasses(q: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = BlueOceanApiFetchParamCreator(configuration).searchClasses(q, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BlueOceanApi - factory interface
 * @export
 */
export const BlueOceanApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete queue item from an organization pipeline queue
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} queue Name of the queue item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipelineQueueItem(organization: string, pipeline: string, queue: string, options?: any) {
            return BlueOceanApiFp(configuration).deletePipelineQueueItem(organization, pipeline, queue, options)(fetch, basePath);
        },
        /**
         * Retrieve authenticated user details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticatedUser(organization: string, options?: any) {
            return BlueOceanApiFp(configuration).getAuthenticatedUser(organization, options)(fetch, basePath);
        },
        /**
         * Get a list of class names supported by a given class
         * @param {string} _class Name of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClasses(_class: string, options?: any) {
            return BlueOceanApiFp(configuration).getClasses(_class, options)(fetch, basePath);
        },
        /**
         * Retrieve JSON Web Key
         * @param {number} key Key ID received as part of JWT header field kid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebKey(key: number, options?: any) {
            return BlueOceanApiFp(configuration).getJsonWebKey(key, options)(fetch, basePath);
        },
        /**
         * Retrieve JSON Web Token
         * @param {number} [expiryTimeInMins] Token expiry time in minutes, default: 30 minutes
         * @param {number} [maxExpiryTimeInMins] Maximum token expiry time in minutes, default: 480 minutes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebToken(expiryTimeInMins?: number, maxExpiryTimeInMins?: number, options?: any) {
            return BlueOceanApiFp(configuration).getJsonWebToken(expiryTimeInMins, maxExpiryTimeInMins, options)(fetch, basePath);
        },
        /**
         * Retrieve organization details
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisation(organization: string, options?: any) {
            return BlueOceanApiFp(configuration).getOrganisation(organization, options)(fetch, basePath);
        },
        /**
         * Retrieve all organizations details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisations(options?: any) {
            return BlueOceanApiFp(configuration).getOrganisations(options)(fetch, basePath);
        },
        /**
         * Retrieve pipeline details for an organization
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipeline(organization: string, pipeline: string, options?: any) {
            return BlueOceanApiFp(configuration).getPipeline(organization, pipeline, options)(fetch, basePath);
        },
        /**
         * Retrieve all activities details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineActivities(organization: string, pipeline: string, options?: any) {
            return BlueOceanApiFp(configuration).getPipelineActivities(organization, pipeline, options)(fetch, basePath);
        },
        /**
         * Retrieve branch details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} branch Name of the branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineBranch(organization: string, pipeline: string, branch: string, options?: any) {
            return BlueOceanApiFp(configuration).getPipelineBranch(organization, pipeline, branch, options)(fetch, basePath);
        },
        /**
         * Retrieve branch run details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} branch Name of the branch
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineBranchRun(organization: string, pipeline: string, branch: string, run: string, options?: any) {
            return BlueOceanApiFp(configuration).getPipelineBranchRun(organization, pipeline, branch, run, options)(fetch, basePath);
        },
        /**
         * Retrieve all branches details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineBranches(organization: string, pipeline: string, options?: any) {
            return BlueOceanApiFp(configuration).getPipelineBranches(organization, pipeline, options)(fetch, basePath);
        },
        /**
         * Retrieve pipeline folder for an organization
         * @param {string} organization Name of the organization
         * @param {string} folder Name of the folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineFolder(organization: string, folder: string, options?: any) {
            return BlueOceanApiFp(configuration).getPipelineFolder(organization, folder, options)(fetch, basePath);
        },
        /**
         * Retrieve pipeline details for an organization folder
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} folder Name of the folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineFolderPipeline(organization: string, pipeline: string, folder: string, options?: any) {
            return BlueOceanApiFp(configuration).getPipelineFolderPipeline(organization, pipeline, folder, options)(fetch, basePath);
        },
        /**
         * Retrieve queue details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineQueue(organization: string, pipeline: string, options?: any) {
            return BlueOceanApiFp(configuration).getPipelineQueue(organization, pipeline, options)(fetch, basePath);
        },
        /**
         * Retrieve run details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRun(organization: string, pipeline: string, run: string, options?: any) {
            return BlueOceanApiFp(configuration).getPipelineRun(organization, pipeline, run, options)(fetch, basePath);
        },
        /**
         * Get log for a pipeline run
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {number} [start] Start position of the log
         * @param {boolean} [download] Set to true in order to download the file, otherwise it&#39;s passed as a response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunLog(organization: string, pipeline: string, run: string, start?: number, download?: boolean, options?: any) {
            return BlueOceanApiFp(configuration).getPipelineRunLog(organization, pipeline, run, start, download, options)(fetch, basePath);
        },
        /**
         * Retrieve run node details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNode(organization: string, pipeline: string, run: string, node: string, options?: any) {
            return BlueOceanApiFp(configuration).getPipelineRunNode(organization, pipeline, run, node, options)(fetch, basePath);
        },
        /**
         * Retrieve run node details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {string} step Name of the step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodeStep(organization: string, pipeline: string, run: string, node: string, step: string, options?: any) {
            return BlueOceanApiFp(configuration).getPipelineRunNodeStep(organization, pipeline, run, node, step, options)(fetch, basePath);
        },
        /**
         * Get log for a pipeline run node step
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {string} step Name of the step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodeStepLog(organization: string, pipeline: string, run: string, node: string, step: string, options?: any) {
            return BlueOceanApiFp(configuration).getPipelineRunNodeStepLog(organization, pipeline, run, node, step, options)(fetch, basePath);
        },
        /**
         * Retrieve run node steps details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodeSteps(organization: string, pipeline: string, run: string, node: string, options?: any) {
            return BlueOceanApiFp(configuration).getPipelineRunNodeSteps(organization, pipeline, run, node, options)(fetch, basePath);
        },
        /**
         * Retrieve run nodes details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodes(organization: string, pipeline: string, run: string, options?: any) {
            return BlueOceanApiFp(configuration).getPipelineRunNodes(organization, pipeline, run, options)(fetch, basePath);
        },
        /**
         * Retrieve all runs details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRuns(organization: string, pipeline: string, options?: any) {
            return BlueOceanApiFp(configuration).getPipelineRuns(organization, pipeline, options)(fetch, basePath);
        },
        /**
         * Retrieve all pipelines details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelines(organization: string, options?: any) {
            return BlueOceanApiFp(configuration).getPipelines(organization, options)(fetch, basePath);
        },
        /**
         * Retrieve SCM details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCM(organization: string, scm: string, options?: any) {
            return BlueOceanApiFp(configuration).getSCM(organization, scm, options)(fetch, basePath);
        },
        /**
         * Retrieve SCM organization repositories details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} scmOrganisation Name of the SCM organization
         * @param {string} [credentialId] Credential ID
         * @param {number} [pageSize] Number of items in a page
         * @param {number} [pageNumber] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCMOrganisationRepositories(organization: string, scm: string, scmOrganisation: string, credentialId?: string, pageSize?: number, pageNumber?: number, options?: any) {
            return BlueOceanApiFp(configuration).getSCMOrganisationRepositories(organization, scm, scmOrganisation, credentialId, pageSize, pageNumber, options)(fetch, basePath);
        },
        /**
         * Retrieve SCM organization repository details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} scmOrganisation Name of the SCM organization
         * @param {string} repository Name of the SCM repository
         * @param {string} [credentialId] Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCMOrganisationRepository(organization: string, scm: string, scmOrganisation: string, repository: string, credentialId?: string, options?: any) {
            return BlueOceanApiFp(configuration).getSCMOrganisationRepository(organization, scm, scmOrganisation, repository, credentialId, options)(fetch, basePath);
        },
        /**
         * Retrieve SCM organizations details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} [credentialId] Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCMOrganisations(organization: string, scm: string, credentialId?: string, options?: any) {
            return BlueOceanApiFp(configuration).getSCMOrganisations(organization, scm, credentialId, options)(fetch, basePath);
        },
        /**
         * Retrieve user details for an organization
         * @param {string} organization Name of the organization
         * @param {string} user Name of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(organization: string, user: string, options?: any) {
            return BlueOceanApiFp(configuration).getUser(organization, user, options)(fetch, basePath);
        },
        /**
         * Retrieve user favorites details for an organization
         * @param {string} user Name of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFavorites(user: string, options?: any) {
            return BlueOceanApiFp(configuration).getUserFavorites(user, options)(fetch, basePath);
        },
        /**
         * Retrieve users details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(organization: string, options?: any) {
            return BlueOceanApiFp(configuration).getUsers(organization, options)(fetch, basePath);
        },
        /**
         * Replay an organization pipeline run
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPipelineRun(organization: string, pipeline: string, run: string, options?: any) {
            return BlueOceanApiFp(configuration).postPipelineRun(organization, pipeline, run, options)(fetch, basePath);
        },
        /**
         * Start a build for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPipelineRuns(organization: string, pipeline: string, options?: any) {
            return BlueOceanApiFp(configuration).postPipelineRuns(organization, pipeline, options)(fetch, basePath);
        },
        /**
         * Favorite/unfavorite a pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {Body} body Set JSON string body to {&quot;favorite&quot;: true} to favorite, set value to false to unfavorite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPipelineFavorite(organization: string, pipeline: string, body: Body, options?: any) {
            return BlueOceanApiFp(configuration).putPipelineFavorite(organization, pipeline, body, options)(fetch, basePath);
        },
        /**
         * Stop a build of an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} [blocking] Set to true to make blocking stop, default: false
         * @param {number} [timeOutInSecs] Timeout in seconds, default: 10 seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPipelineRun(organization: string, pipeline: string, run: string, blocking?: string, timeOutInSecs?: number, options?: any) {
            return BlueOceanApiFp(configuration).putPipelineRun(organization, pipeline, run, blocking, timeOutInSecs, options)(fetch, basePath);
        },
        /**
         * Search for any resource details
         * @param {string} q Query string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(q: string, options?: any) {
            return BlueOceanApiFp(configuration).search(q, options)(fetch, basePath);
        },
        /**
         * Get classes details
         * @param {string} q Query string containing an array of class names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchClasses(q: string, options?: any) {
            return BlueOceanApiFp(configuration).searchClasses(q, options)(fetch, basePath);
        },
    };
};

/**
 * BlueOceanApi - object-oriented interface
 * @export
 * @class BlueOceanApi
 * @extends {BaseAPI}
 */
export class BlueOceanApi extends BaseAPI {
    /**
     * Delete queue item from an organization pipeline queue
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} queue Name of the queue item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public deletePipelineQueueItem(organization: string, pipeline: string, queue: string, options?: any) {
        return BlueOceanApiFp(this.configuration).deletePipelineQueueItem(organization, pipeline, queue, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve authenticated user details for an organization
     * @param {string} organization Name of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getAuthenticatedUser(organization: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getAuthenticatedUser(organization, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of class names supported by a given class
     * @param {string} _class Name of the class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getClasses(_class: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getClasses(_class, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve JSON Web Key
     * @param {number} key Key ID received as part of JWT header field kid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getJsonWebKey(key: number, options?: any) {
        return BlueOceanApiFp(this.configuration).getJsonWebKey(key, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve JSON Web Token
     * @param {number} [expiryTimeInMins] Token expiry time in minutes, default: 30 minutes
     * @param {number} [maxExpiryTimeInMins] Maximum token expiry time in minutes, default: 480 minutes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getJsonWebToken(expiryTimeInMins?: number, maxExpiryTimeInMins?: number, options?: any) {
        return BlueOceanApiFp(this.configuration).getJsonWebToken(expiryTimeInMins, maxExpiryTimeInMins, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve organization details
     * @param {string} organization Name of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getOrganisation(organization: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getOrganisation(organization, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all organizations details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getOrganisations(options?: any) {
        return BlueOceanApiFp(this.configuration).getOrganisations(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve pipeline details for an organization
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipeline(organization: string, pipeline: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getPipeline(organization, pipeline, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all activities details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineActivities(organization: string, pipeline: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getPipelineActivities(organization, pipeline, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve branch details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} branch Name of the branch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineBranch(organization: string, pipeline: string, branch: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getPipelineBranch(organization, pipeline, branch, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve branch run details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} branch Name of the branch
     * @param {string} run Name of the run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineBranchRun(organization: string, pipeline: string, branch: string, run: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getPipelineBranchRun(organization, pipeline, branch, run, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all branches details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineBranches(organization: string, pipeline: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getPipelineBranches(organization, pipeline, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve pipeline folder for an organization
     * @param {string} organization Name of the organization
     * @param {string} folder Name of the folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineFolder(organization: string, folder: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getPipelineFolder(organization, folder, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve pipeline details for an organization folder
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} folder Name of the folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineFolderPipeline(organization: string, pipeline: string, folder: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getPipelineFolderPipeline(organization, pipeline, folder, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve queue details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineQueue(organization: string, pipeline: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getPipelineQueue(organization, pipeline, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve run details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineRun(organization: string, pipeline: string, run: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getPipelineRun(organization, pipeline, run, options)(this.fetch, this.basePath);
    }

    /**
     * Get log for a pipeline run
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {number} [start] Start position of the log
     * @param {boolean} [download] Set to true in order to download the file, otherwise it&#39;s passed as a response body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineRunLog(organization: string, pipeline: string, run: string, start?: number, download?: boolean, options?: any) {
        return BlueOceanApiFp(this.configuration).getPipelineRunLog(organization, pipeline, run, start, download, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve run node details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {string} node Name of the node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineRunNode(organization: string, pipeline: string, run: string, node: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getPipelineRunNode(organization, pipeline, run, node, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve run node details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {string} node Name of the node
     * @param {string} step Name of the step
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineRunNodeStep(organization: string, pipeline: string, run: string, node: string, step: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getPipelineRunNodeStep(organization, pipeline, run, node, step, options)(this.fetch, this.basePath);
    }

    /**
     * Get log for a pipeline run node step
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {string} node Name of the node
     * @param {string} step Name of the step
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineRunNodeStepLog(organization: string, pipeline: string, run: string, node: string, step: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getPipelineRunNodeStepLog(organization, pipeline, run, node, step, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve run node steps details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {string} node Name of the node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineRunNodeSteps(organization: string, pipeline: string, run: string, node: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getPipelineRunNodeSteps(organization, pipeline, run, node, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve run nodes details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineRunNodes(organization: string, pipeline: string, run: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getPipelineRunNodes(organization, pipeline, run, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all runs details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineRuns(organization: string, pipeline: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getPipelineRuns(organization, pipeline, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all pipelines details for an organization
     * @param {string} organization Name of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelines(organization: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getPipelines(organization, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve SCM details for an organization
     * @param {string} organization Name of the organization
     * @param {string} scm Name of SCM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getSCM(organization: string, scm: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getSCM(organization, scm, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve SCM organization repositories details for an organization
     * @param {string} organization Name of the organization
     * @param {string} scm Name of SCM
     * @param {string} scmOrganisation Name of the SCM organization
     * @param {string} [credentialId] Credential ID
     * @param {number} [pageSize] Number of items in a page
     * @param {number} [pageNumber] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getSCMOrganisationRepositories(organization: string, scm: string, scmOrganisation: string, credentialId?: string, pageSize?: number, pageNumber?: number, options?: any) {
        return BlueOceanApiFp(this.configuration).getSCMOrganisationRepositories(organization, scm, scmOrganisation, credentialId, pageSize, pageNumber, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve SCM organization repository details for an organization
     * @param {string} organization Name of the organization
     * @param {string} scm Name of SCM
     * @param {string} scmOrganisation Name of the SCM organization
     * @param {string} repository Name of the SCM repository
     * @param {string} [credentialId] Credential ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getSCMOrganisationRepository(organization: string, scm: string, scmOrganisation: string, repository: string, credentialId?: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getSCMOrganisationRepository(organization, scm, scmOrganisation, repository, credentialId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve SCM organizations details for an organization
     * @param {string} organization Name of the organization
     * @param {string} scm Name of SCM
     * @param {string} [credentialId] Credential ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getSCMOrganisations(organization: string, scm: string, credentialId?: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getSCMOrganisations(organization, scm, credentialId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve user details for an organization
     * @param {string} organization Name of the organization
     * @param {string} user Name of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getUser(organization: string, user: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getUser(organization, user, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve user favorites details for an organization
     * @param {string} user Name of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getUserFavorites(user: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getUserFavorites(user, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve users details for an organization
     * @param {string} organization Name of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getUsers(organization: string, options?: any) {
        return BlueOceanApiFp(this.configuration).getUsers(organization, options)(this.fetch, this.basePath);
    }

    /**
     * Replay an organization pipeline run
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public postPipelineRun(organization: string, pipeline: string, run: string, options?: any) {
        return BlueOceanApiFp(this.configuration).postPipelineRun(organization, pipeline, run, options)(this.fetch, this.basePath);
    }

    /**
     * Start a build for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public postPipelineRuns(organization: string, pipeline: string, options?: any) {
        return BlueOceanApiFp(this.configuration).postPipelineRuns(organization, pipeline, options)(this.fetch, this.basePath);
    }

    /**
     * Favorite/unfavorite a pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {Body} body Set JSON string body to {&quot;favorite&quot;: true} to favorite, set value to false to unfavorite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public putPipelineFavorite(organization: string, pipeline: string, body: Body, options?: any) {
        return BlueOceanApiFp(this.configuration).putPipelineFavorite(organization, pipeline, body, options)(this.fetch, this.basePath);
    }

    /**
     * Stop a build of an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {string} [blocking] Set to true to make blocking stop, default: false
     * @param {number} [timeOutInSecs] Timeout in seconds, default: 10 seconds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public putPipelineRun(organization: string, pipeline: string, run: string, blocking?: string, timeOutInSecs?: number, options?: any) {
        return BlueOceanApiFp(this.configuration).putPipelineRun(organization, pipeline, run, blocking, timeOutInSecs, options)(this.fetch, this.basePath);
    }

    /**
     * Search for any resource details
     * @param {string} q Query string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public search(q: string, options?: any) {
        return BlueOceanApiFp(this.configuration).search(q, options)(this.fetch, this.basePath);
    }

    /**
     * Get classes details
     * @param {string} q Query string containing an array of class names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public searchClasses(q: string, options?: any) {
        return BlueOceanApiFp(this.configuration).searchClasses(q, options)(this.fetch, this.basePath);
    }

}

/**
 * RemoteAccessApi - fetch parameter creator
 * @export
 */
export const RemoteAccessApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve computer details
         * @param {number} depth Recursion depth in response model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComputer(depth: number, options: any = {}): FetchArgs {
            // verify required parameter 'depth' is not null or undefined
            if (depth === null || depth === undefined) {
                throw new RequiredError('depth','Required parameter depth was null or undefined when calling getComputer.');
            }
            const localVarPath = `/computer/api/json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrumb(options: any = {}): FetchArgs {
            const localVarPath = `/crumbIssuer/api/json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Jenkins details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJenkins(options: any = {}): FetchArgs {
            const localVarPath = `/api/json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve job details
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getJob.');
            }
            const localVarPath = `/job/{name}/api/json`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve job configuration
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobConfig(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getJobConfig.');
            }
            const localVarPath = `/job/{name}/config.xml`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve job's last build details
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobLastBuild(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getJobLastBuild.');
            }
            const localVarPath = `/job/{name}/lastBuild/api/json`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve job's build progressive text output
         * @param {string} name Name of the job
         * @param {string} number Build number
         * @param {string} start Starting point of progressive text output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobProgressiveText(name: string, number: string, start: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getJobProgressiveText.');
            }
            // verify required parameter 'number' is not null or undefined
            if (number === null || number === undefined) {
                throw new RequiredError('number','Required parameter number was null or undefined when calling getJobProgressiveText.');
            }
            // verify required parameter 'start' is not null or undefined
            if (start === null || start === undefined) {
                throw new RequiredError('start','Required parameter start was null or undefined when calling getJobProgressiveText.');
            }
            const localVarPath = `/job/{name}/{number}/logText/progressiveText`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve queue details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueue(options: any = {}): FetchArgs {
            const localVarPath = `/queue/api/json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve queued item details
         * @param {string} number Queue number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueItem(number: string, options: any = {}): FetchArgs {
            // verify required parameter 'number' is not null or undefined
            if (number === null || number === undefined) {
                throw new RequiredError('number','Required parameter number was null or undefined when calling getQueueItem.');
            }
            const localVarPath = `/queue/item/{number}/api/json`
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve view details
         * @param {string} name Name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getView(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getView.');
            }
            const localVarPath = `/view/{name}/api/json`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve view configuration
         * @param {string} name Name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewConfig(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getViewConfig.');
            }
            const localVarPath = `/view/{name}/config.xml`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Jenkins headers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headJenkins(options: any = {}): FetchArgs {
            const localVarPath = `/api/json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new job using job configuration, or copied from an existing job
         * @param {string} name Name of the new job
         * @param {string} [from] Existing job to copy from
         * @param {string} [mode] Set to &#39;copy&#39; for copying an existing job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {string} [contentType] Content type header application/xml
         * @param {string} [body] Job configuration in config.xml format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateItem(name: string, from?: string, mode?: string, jenkinsCrumb?: string, contentType?: string, body?: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postCreateItem.');
            }
            const localVarPath = `/createItem`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (jenkinsCrumb !== undefined && jenkinsCrumb !== null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new view using view configuration
         * @param {string} name Name of the new view
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {string} [contentType] Content type header application/xml
         * @param {string} [body] View configuration in config.xml format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateView(name: string, jenkinsCrumb?: string, contentType?: string, body?: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postCreateView.');
            }
            const localVarPath = `/createView`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (jenkinsCrumb !== undefined && jenkinsCrumb !== null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Build a job
         * @param {string} name Name of the job
         * @param {string} json 
         * @param {string} [token] 
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobBuild(name: string, json: string, token?: string, jenkinsCrumb?: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postJobBuild.');
            }
            // verify required parameter 'json' is not null or undefined
            if (json === null || json === undefined) {
                throw new RequiredError('json','Required parameter json was null or undefined when calling postJobBuild.');
            }
            const localVarPath = `/job/{name}/build`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (json !== undefined) {
                localVarQueryParameter['json'] = json;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (jenkinsCrumb !== undefined && jenkinsCrumb !== null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update job configuration
         * @param {string} name Name of the job
         * @param {string} body Job configuration in config.xml format
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobConfig(name: string, body: string, jenkinsCrumb?: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postJobConfig.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postJobConfig.');
            }
            const localVarPath = `/job/{name}/config.xml`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (jenkinsCrumb !== undefined && jenkinsCrumb !== null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobDelete(name: string, jenkinsCrumb?: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postJobDelete.');
            }
            const localVarPath = `/job/{name}/doDelete`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (jenkinsCrumb !== undefined && jenkinsCrumb !== null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobDisable(name: string, jenkinsCrumb?: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postJobDisable.');
            }
            const localVarPath = `/job/{name}/disable`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (jenkinsCrumb !== undefined && jenkinsCrumb !== null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobEnable(name: string, jenkinsCrumb?: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postJobEnable.');
            }
            const localVarPath = `/job/{name}/enable`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (jenkinsCrumb !== undefined && jenkinsCrumb !== null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobLastBuildStop(name: string, jenkinsCrumb?: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postJobLastBuildStop.');
            }
            const localVarPath = `/job/{name}/lastBuild/stop`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (jenkinsCrumb !== undefined && jenkinsCrumb !== null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update view configuration
         * @param {string} name Name of the view
         * @param {string} body View configuration in config.xml format
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postViewConfig(name: string, body: string, jenkinsCrumb?: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postViewConfig.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postViewConfig.');
            }
            const localVarPath = `/view/{name}/config.xml`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (jenkinsCrumb !== undefined && jenkinsCrumb !== null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RemoteAccessApi - functional programming interface
 * @export
 */
export const RemoteAccessApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve computer details
         * @param {number} depth Recursion depth in response model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComputer(depth: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ComputerSet> {
            const localVarFetchArgs = RemoteAccessApiFetchParamCreator(configuration).getComputer(depth, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrumb(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefaultCrumbIssuer> {
            const localVarFetchArgs = RemoteAccessApiFetchParamCreator(configuration).getCrumb(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve Jenkins details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJenkins(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Hudson> {
            const localVarFetchArgs = RemoteAccessApiFetchParamCreator(configuration).getJenkins(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve job details
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FreeStyleProject> {
            const localVarFetchArgs = RemoteAccessApiFetchParamCreator(configuration).getJob(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve job configuration
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobConfig(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = RemoteAccessApiFetchParamCreator(configuration).getJobConfig(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve job's last build details
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobLastBuild(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FreeStyleBuild> {
            const localVarFetchArgs = RemoteAccessApiFetchParamCreator(configuration).getJobLastBuild(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve job's build progressive text output
         * @param {string} name Name of the job
         * @param {string} number Build number
         * @param {string} start Starting point of progressive text output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobProgressiveText(name: string, number: string, start: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RemoteAccessApiFetchParamCreator(configuration).getJobProgressiveText(name, number, start, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve queue details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueue(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Queue> {
            const localVarFetchArgs = RemoteAccessApiFetchParamCreator(configuration).getQueue(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve queued item details
         * @param {string} number Queue number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueItem(number: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Queue> {
            const localVarFetchArgs = RemoteAccessApiFetchParamCreator(configuration).getQueueItem(number, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve view details
         * @param {string} name Name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getView(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListView> {
            const localVarFetchArgs = RemoteAccessApiFetchParamCreator(configuration).getView(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve view configuration
         * @param {string} name Name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewConfig(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = RemoteAccessApiFetchParamCreator(configuration).getViewConfig(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve Jenkins headers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headJenkins(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RemoteAccessApiFetchParamCreator(configuration).headJenkins(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new job using job configuration, or copied from an existing job
         * @param {string} name Name of the new job
         * @param {string} [from] Existing job to copy from
         * @param {string} [mode] Set to &#39;copy&#39; for copying an existing job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {string} [contentType] Content type header application/xml
         * @param {string} [body] Job configuration in config.xml format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateItem(name: string, from?: string, mode?: string, jenkinsCrumb?: string, contentType?: string, body?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RemoteAccessApiFetchParamCreator(configuration).postCreateItem(name, from, mode, jenkinsCrumb, contentType, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new view using view configuration
         * @param {string} name Name of the new view
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {string} [contentType] Content type header application/xml
         * @param {string} [body] View configuration in config.xml format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateView(name: string, jenkinsCrumb?: string, contentType?: string, body?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RemoteAccessApiFetchParamCreator(configuration).postCreateView(name, jenkinsCrumb, contentType, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Build a job
         * @param {string} name Name of the job
         * @param {string} json 
         * @param {string} [token] 
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobBuild(name: string, json: string, token?: string, jenkinsCrumb?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RemoteAccessApiFetchParamCreator(configuration).postJobBuild(name, json, token, jenkinsCrumb, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update job configuration
         * @param {string} name Name of the job
         * @param {string} body Job configuration in config.xml format
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobConfig(name: string, body: string, jenkinsCrumb?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RemoteAccessApiFetchParamCreator(configuration).postJobConfig(name, body, jenkinsCrumb, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobDelete(name: string, jenkinsCrumb?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RemoteAccessApiFetchParamCreator(configuration).postJobDelete(name, jenkinsCrumb, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Disable a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobDisable(name: string, jenkinsCrumb?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RemoteAccessApiFetchParamCreator(configuration).postJobDisable(name, jenkinsCrumb, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Enable a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobEnable(name: string, jenkinsCrumb?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RemoteAccessApiFetchParamCreator(configuration).postJobEnable(name, jenkinsCrumb, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Stop a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobLastBuildStop(name: string, jenkinsCrumb?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RemoteAccessApiFetchParamCreator(configuration).postJobLastBuildStop(name, jenkinsCrumb, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update view configuration
         * @param {string} name Name of the view
         * @param {string} body View configuration in config.xml format
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postViewConfig(name: string, body: string, jenkinsCrumb?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RemoteAccessApiFetchParamCreator(configuration).postViewConfig(name, body, jenkinsCrumb, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RemoteAccessApi - factory interface
 * @export
 */
export const RemoteAccessApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve computer details
         * @param {number} depth Recursion depth in response model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComputer(depth: number, options?: any) {
            return RemoteAccessApiFp(configuration).getComputer(depth, options)(fetch, basePath);
        },
        /**
         * Retrieve CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrumb(options?: any) {
            return RemoteAccessApiFp(configuration).getCrumb(options)(fetch, basePath);
        },
        /**
         * Retrieve Jenkins details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJenkins(options?: any) {
            return RemoteAccessApiFp(configuration).getJenkins(options)(fetch, basePath);
        },
        /**
         * Retrieve job details
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(name: string, options?: any) {
            return RemoteAccessApiFp(configuration).getJob(name, options)(fetch, basePath);
        },
        /**
         * Retrieve job configuration
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobConfig(name: string, options?: any) {
            return RemoteAccessApiFp(configuration).getJobConfig(name, options)(fetch, basePath);
        },
        /**
         * Retrieve job's last build details
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobLastBuild(name: string, options?: any) {
            return RemoteAccessApiFp(configuration).getJobLastBuild(name, options)(fetch, basePath);
        },
        /**
         * Retrieve job's build progressive text output
         * @param {string} name Name of the job
         * @param {string} number Build number
         * @param {string} start Starting point of progressive text output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobProgressiveText(name: string, number: string, start: string, options?: any) {
            return RemoteAccessApiFp(configuration).getJobProgressiveText(name, number, start, options)(fetch, basePath);
        },
        /**
         * Retrieve queue details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueue(options?: any) {
            return RemoteAccessApiFp(configuration).getQueue(options)(fetch, basePath);
        },
        /**
         * Retrieve queued item details
         * @param {string} number Queue number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueItem(number: string, options?: any) {
            return RemoteAccessApiFp(configuration).getQueueItem(number, options)(fetch, basePath);
        },
        /**
         * Retrieve view details
         * @param {string} name Name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getView(name: string, options?: any) {
            return RemoteAccessApiFp(configuration).getView(name, options)(fetch, basePath);
        },
        /**
         * Retrieve view configuration
         * @param {string} name Name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewConfig(name: string, options?: any) {
            return RemoteAccessApiFp(configuration).getViewConfig(name, options)(fetch, basePath);
        },
        /**
         * Retrieve Jenkins headers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headJenkins(options?: any) {
            return RemoteAccessApiFp(configuration).headJenkins(options)(fetch, basePath);
        },
        /**
         * Create a new job using job configuration, or copied from an existing job
         * @param {string} name Name of the new job
         * @param {string} [from] Existing job to copy from
         * @param {string} [mode] Set to &#39;copy&#39; for copying an existing job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {string} [contentType] Content type header application/xml
         * @param {string} [body] Job configuration in config.xml format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateItem(name: string, from?: string, mode?: string, jenkinsCrumb?: string, contentType?: string, body?: string, options?: any) {
            return RemoteAccessApiFp(configuration).postCreateItem(name, from, mode, jenkinsCrumb, contentType, body, options)(fetch, basePath);
        },
        /**
         * Create a new view using view configuration
         * @param {string} name Name of the new view
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {string} [contentType] Content type header application/xml
         * @param {string} [body] View configuration in config.xml format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateView(name: string, jenkinsCrumb?: string, contentType?: string, body?: string, options?: any) {
            return RemoteAccessApiFp(configuration).postCreateView(name, jenkinsCrumb, contentType, body, options)(fetch, basePath);
        },
        /**
         * Build a job
         * @param {string} name Name of the job
         * @param {string} json 
         * @param {string} [token] 
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobBuild(name: string, json: string, token?: string, jenkinsCrumb?: string, options?: any) {
            return RemoteAccessApiFp(configuration).postJobBuild(name, json, token, jenkinsCrumb, options)(fetch, basePath);
        },
        /**
         * Update job configuration
         * @param {string} name Name of the job
         * @param {string} body Job configuration in config.xml format
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobConfig(name: string, body: string, jenkinsCrumb?: string, options?: any) {
            return RemoteAccessApiFp(configuration).postJobConfig(name, body, jenkinsCrumb, options)(fetch, basePath);
        },
        /**
         * Delete a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobDelete(name: string, jenkinsCrumb?: string, options?: any) {
            return RemoteAccessApiFp(configuration).postJobDelete(name, jenkinsCrumb, options)(fetch, basePath);
        },
        /**
         * Disable a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobDisable(name: string, jenkinsCrumb?: string, options?: any) {
            return RemoteAccessApiFp(configuration).postJobDisable(name, jenkinsCrumb, options)(fetch, basePath);
        },
        /**
         * Enable a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobEnable(name: string, jenkinsCrumb?: string, options?: any) {
            return RemoteAccessApiFp(configuration).postJobEnable(name, jenkinsCrumb, options)(fetch, basePath);
        },
        /**
         * Stop a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobLastBuildStop(name: string, jenkinsCrumb?: string, options?: any) {
            return RemoteAccessApiFp(configuration).postJobLastBuildStop(name, jenkinsCrumb, options)(fetch, basePath);
        },
        /**
         * Update view configuration
         * @param {string} name Name of the view
         * @param {string} body View configuration in config.xml format
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postViewConfig(name: string, body: string, jenkinsCrumb?: string, options?: any) {
            return RemoteAccessApiFp(configuration).postViewConfig(name, body, jenkinsCrumb, options)(fetch, basePath);
        },
    };
};

/**
 * RemoteAccessApi - object-oriented interface
 * @export
 * @class RemoteAccessApi
 * @extends {BaseAPI}
 */
export class RemoteAccessApi extends BaseAPI {
    /**
     * Retrieve computer details
     * @param {number} depth Recursion depth in response model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public getComputer(depth: number, options?: any) {
        return RemoteAccessApiFp(this.configuration).getComputer(depth, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public getCrumb(options?: any) {
        return RemoteAccessApiFp(this.configuration).getCrumb(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve Jenkins details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public getJenkins(options?: any) {
        return RemoteAccessApiFp(this.configuration).getJenkins(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve job details
     * @param {string} name Name of the job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public getJob(name: string, options?: any) {
        return RemoteAccessApiFp(this.configuration).getJob(name, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve job configuration
     * @param {string} name Name of the job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public getJobConfig(name: string, options?: any) {
        return RemoteAccessApiFp(this.configuration).getJobConfig(name, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve job's last build details
     * @param {string} name Name of the job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public getJobLastBuild(name: string, options?: any) {
        return RemoteAccessApiFp(this.configuration).getJobLastBuild(name, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve job's build progressive text output
     * @param {string} name Name of the job
     * @param {string} number Build number
     * @param {string} start Starting point of progressive text output
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public getJobProgressiveText(name: string, number: string, start: string, options?: any) {
        return RemoteAccessApiFp(this.configuration).getJobProgressiveText(name, number, start, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve queue details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public getQueue(options?: any) {
        return RemoteAccessApiFp(this.configuration).getQueue(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve queued item details
     * @param {string} number Queue number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public getQueueItem(number: string, options?: any) {
        return RemoteAccessApiFp(this.configuration).getQueueItem(number, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve view details
     * @param {string} name Name of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public getView(name: string, options?: any) {
        return RemoteAccessApiFp(this.configuration).getView(name, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve view configuration
     * @param {string} name Name of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public getViewConfig(name: string, options?: any) {
        return RemoteAccessApiFp(this.configuration).getViewConfig(name, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve Jenkins headers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public headJenkins(options?: any) {
        return RemoteAccessApiFp(this.configuration).headJenkins(options)(this.fetch, this.basePath);
    }

    /**
     * Create a new job using job configuration, or copied from an existing job
     * @param {string} name Name of the new job
     * @param {string} [from] Existing job to copy from
     * @param {string} [mode] Set to &#39;copy&#39; for copying an existing job
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {string} [contentType] Content type header application/xml
     * @param {string} [body] Job configuration in config.xml format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public postCreateItem(name: string, from?: string, mode?: string, jenkinsCrumb?: string, contentType?: string, body?: string, options?: any) {
        return RemoteAccessApiFp(this.configuration).postCreateItem(name, from, mode, jenkinsCrumb, contentType, body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new view using view configuration
     * @param {string} name Name of the new view
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {string} [contentType] Content type header application/xml
     * @param {string} [body] View configuration in config.xml format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public postCreateView(name: string, jenkinsCrumb?: string, contentType?: string, body?: string, options?: any) {
        return RemoteAccessApiFp(this.configuration).postCreateView(name, jenkinsCrumb, contentType, body, options)(this.fetch, this.basePath);
    }

    /**
     * Build a job
     * @param {string} name Name of the job
     * @param {string} json 
     * @param {string} [token] 
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public postJobBuild(name: string, json: string, token?: string, jenkinsCrumb?: string, options?: any) {
        return RemoteAccessApiFp(this.configuration).postJobBuild(name, json, token, jenkinsCrumb, options)(this.fetch, this.basePath);
    }

    /**
     * Update job configuration
     * @param {string} name Name of the job
     * @param {string} body Job configuration in config.xml format
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public postJobConfig(name: string, body: string, jenkinsCrumb?: string, options?: any) {
        return RemoteAccessApiFp(this.configuration).postJobConfig(name, body, jenkinsCrumb, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a job
     * @param {string} name Name of the job
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public postJobDelete(name: string, jenkinsCrumb?: string, options?: any) {
        return RemoteAccessApiFp(this.configuration).postJobDelete(name, jenkinsCrumb, options)(this.fetch, this.basePath);
    }

    /**
     * Disable a job
     * @param {string} name Name of the job
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public postJobDisable(name: string, jenkinsCrumb?: string, options?: any) {
        return RemoteAccessApiFp(this.configuration).postJobDisable(name, jenkinsCrumb, options)(this.fetch, this.basePath);
    }

    /**
     * Enable a job
     * @param {string} name Name of the job
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public postJobEnable(name: string, jenkinsCrumb?: string, options?: any) {
        return RemoteAccessApiFp(this.configuration).postJobEnable(name, jenkinsCrumb, options)(this.fetch, this.basePath);
    }

    /**
     * Stop a job
     * @param {string} name Name of the job
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public postJobLastBuildStop(name: string, jenkinsCrumb?: string, options?: any) {
        return RemoteAccessApiFp(this.configuration).postJobLastBuildStop(name, jenkinsCrumb, options)(this.fetch, this.basePath);
    }

    /**
     * Update view configuration
     * @param {string} name Name of the view
     * @param {string} body View configuration in config.xml format
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public postViewConfig(name: string, body: string, jenkinsCrumb?: string, options?: any) {
        return RemoteAccessApiFp(this.configuration).postViewConfig(name, body, jenkinsCrumb, options)(this.fetch, this.basePath);
    }

}

